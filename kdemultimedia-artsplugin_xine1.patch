diff -urN kdemultimedia-3.1/xine_artsplugin.old/Makefile.am kdemultimedia-3.1/xine_artsplugin/Makefile.am
--- kdemultimedia-3.1/xine_artsplugin.old/Makefile.am	Sun Oct 27 00:20:56 2002
+++ kdemultimedia-3.1/xine_artsplugin/Makefile.am	Thu Dec  5 21:10:14 2002
@@ -1,13 +1,10 @@
-INCLUDES= -I$(kde_includes)/arts $(all_includes) $(XINE_INCS)
-
-AM_CFLAGS = -U__STRICT_ANSI__ $(XINE_CFLAGS)
+INCLUDES= -I$(kde_includes)/arts $(all_includes) $(XINE_CFLAGS)
 
 lib_LTLIBRARIES = libarts_xine.la
 
 libarts_xine_la_SOURCES = xinePlayObject.cc \
 			  xinePlayObject_impl.cpp \
-			  audio_fifo_out.c \
-			  video_fifo_out.c
+			  audio_fifo_out.c
 libarts_xine_la_LDFLAGS = $(all_libraries) -module -avoid-version -pthread
 libarts_xine_la_LIBADD = $(XINE_LIBS) $(LIB_X11) $(LIB_XEXT) \
 			 -lkmedia2_idl -lsoundserver_idl -lartsflow
@@ -18,7 +15,7 @@
 xinePlayObject.cc xinePlayObject.h: $(srcdir)/xinePlayObject.idl
 	$(MCOPIDL) $(INCLUDES) $(srcdir)/xinePlayObject.idl
 
-noinst_HEADERS = xinePlayObject_impl.h audio_fifo_out.h video_fifo_out.h
+noinst_HEADERS = xinePlayObject_impl.h audio_fifo_out.h
 
 mcopclassdir = $(libdir)/mcop
 mcopclass_DATA = xinePlayObject.mcopclass
diff -urN kdemultimedia-3.1/xine_artsplugin.old/audio_fifo_out.c kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.c
--- kdemultimedia-3.1/xine_artsplugin.old/audio_fifo_out.c	Fri Nov 22 20:42:23 2002
+++ kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.c	Thu Dec  5 21:10:14 2002
@@ -12,14 +12,22 @@
 #include <config.h>
 #endif
 
+/* FIXME: xine bug? */
+#define HAVE_SETENV
+#define HAVE_STRPBRK
+#define HAVE_STRSEP
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <inttypes.h>
+#include <malloc.h>
 #include <pthread.h>
+#include <time.h>
 #include <sys/time.h>
 #include <xine/xine_internal.h>
 #include <xine/audio_out.h>
+
 #include "audio_fifo_out.h"
 
 #define GAP_TOLERANCE	5000
@@ -33,8 +41,9 @@
     int		     capabilities;
     int		     mode;
     int		     enabled;
-    int		     locked;
-    pthread_mutex_t  mutex;
+    int		     close_delay;
+    pthread_mutex_t  read_mutex;
+    pthread_mutex_t  write_mutex;
     pthread_cond_t   cond;
 
     uint32_t	     bytes_per_frame;
@@ -63,6 +72,7 @@
     ao->fifo_read_ptr		= 0;
     ao->fifo_write_ptr		= 0;
     ao->bytes_in_buffer		= 0;
+    ao->close_delay		= 0;
 
     switch (mode)
     {
@@ -77,10 +87,10 @@
     ao->buffer_size	= ao->audio->sample_rate * ao->bytes_per_frame;
     ao->fifo		= malloc( (ao->buffer_size << 1) );
 
-    pthread_mutex_lock( &ao->mutex );
-    ao->enabled = 1;
-    ao->locked  = 0;
-    pthread_mutex_unlock( &ao->mutex );
+    /* enable audio */
+    pthread_mutex_lock( &ao->write_mutex );
+    ao->enabled		= 1;
+    pthread_mutex_unlock( &ao->write_mutex );
 
     return ao->audio->sample_rate;
 }
@@ -121,7 +131,7 @@
     }
     if ((ao->bytes_in_buffer + n) > ao->buffer_size)
     {
-	pthread_mutex_lock( &ao->mutex );
+	pthread_mutex_lock( &ao->write_mutex );
 
 	while ((ao->bytes_in_buffer + n) > ao->buffer_size)
 	{
@@ -132,8 +142,9 @@
 	    if (!ao->enabled)
 	    {
 		/* audio has stopped */
-		pthread_mutex_unlock( &ao->mutex );
-		return 0;
+		pthread_mutex_unlock( &ao->write_mutex );
+		ao->close_delay += n;
+		return 1;
 	    }
 
 	    gettimeofday( &tv, 0 );
@@ -152,31 +163,37 @@
 		ts.tv_sec++;
 		ts.tv_nsec -= 1000000000;
 	    }
-	    if (pthread_cond_timedwait( &ao->cond, &ao->mutex, &ts ) != 0)
+	    if (pthread_cond_timedwait( &ao->cond, &ao->write_mutex, &ts ) != 0)
 	    {
 		fprintf( stderr, "fifo_audio_out: blocked for more than %d ms,\n", delay);
 		fprintf( stderr, "fifo_audio_out: %d sample(s) discarded.\n", num_frames);
-		pthread_mutex_unlock( &ao->mutex );
+		pthread_mutex_unlock( &ao->write_mutex );
 		return 0;
 	    }
 	}
-	pthread_mutex_unlock( &ao->mutex );
+	pthread_mutex_unlock( &ao->write_mutex );
     }
-    if (n >= m)
+    if (n > 0)
     {
-	memcpy( (ao->fifo + w), src, m );
-	w = (n - m);
-	memcpy( ao->fifo, src + m, w );
-    }
-    else
-    {
-	memcpy( (ao->fifo + w), src, n );
-	w += n;
+	if (n >= m)
+	{
+	    memcpy( (ao->fifo + w), src, m );
+	    w = (n - m);
+	    memcpy( ao->fifo, src + m, w );
+	}
+	else
+	{
+	    memcpy( (ao->fifo + w), src, n );
+	    w += n;
+	}
     }
-    pthread_mutex_lock( &ao->mutex );
-    ao->fifo_write_ptr = w;
+
+    /* update audio buffer pointer */
+    pthread_mutex_lock( &ao->write_mutex );
+    ao->fifo_write_ptr   = w;
     ao->bytes_in_buffer += n;
-    pthread_mutex_unlock( &ao->mutex );
+    pthread_mutex_unlock( &ao->write_mutex );
+
     return 1;
 }
 
@@ -184,28 +201,29 @@
 {
     fifo_driver_t *ao = (fifo_driver_t *)this_gen;
     return (ao_fifo_arts_delay() * ao->audio->sample_rate / 1000)
-	   + (ao->bytes_in_buffer / ao->bytes_per_frame);
+	   + ((ao->bytes_in_buffer + ao->close_delay) / ao->bytes_per_frame);
 }
 
 static void ao_fifo_close( ao_driver_t *this_gen )
 {
     fifo_driver_t *ao = (fifo_driver_t *)this_gen;
 
-    pthread_mutex_lock( &ao->mutex );
-
-    while (ao->bytes_in_buffer && ao->enabled)
-    {
-	pthread_cond_wait( &ao->cond, &ao->mutex );
-    }
-    pthread_mutex_unlock( &ao->mutex );
+    /* lock read buffer */
+    pthread_mutex_lock( &ao->read_mutex );
+    pthread_mutex_lock( &ao->write_mutex );
 
-    ao_fifo_wait_close( this_gen );
+    /* disable audio driver */
+    ao->enabled = 0;
+    ao->close_delay = 0;
 
+    /* free audio FIFO */
     if (ao->fifo)
     {
 	free( ao->fifo );
 	ao->fifo = NULL;
     }
+    pthread_mutex_unlock( &ao->write_mutex );
+    pthread_mutex_unlock( &ao->read_mutex );
 }
 
 static uint32_t ao_fifo_get_capabilities( ao_driver_t *this_gen )
@@ -220,7 +238,9 @@
     ao_fifo_close( this_gen );
 
     pthread_cond_destroy( &ao->cond );
-    pthread_mutex_destroy( &ao->mutex );
+    pthread_mutex_destroy( &ao->read_mutex );
+    pthread_mutex_destroy( &ao->write_mutex );
+
     free( ao );
 }
 
@@ -236,10 +256,31 @@
 
 static int ao_fifo_control( ao_driver_t *this_gen, int cmd, ... )
 {
+    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
+
+    switch (cmd)
+    {
+    case AO_CTRL_FLUSH_BUFFERS:
+    case AO_CTRL_PLAY_PAUSE:
+	/* flush audio FIFO */
+	pthread_mutex_lock( &ao->read_mutex );
+	pthread_mutex_lock( &ao->write_mutex );
+
+	ao->fifo_read_ptr = ao->fifo_write_ptr;
+	ao->bytes_in_buffer = 0;
+
+	pthread_cond_broadcast( &ao->cond );
+	pthread_mutex_unlock( &ao->write_mutex );
+	pthread_mutex_unlock( &ao->read_mutex );
+	break;
+
+    case AO_CTRL_PLAY_RESUME:
+	break;
+    }
     return 0;
 }
 
-ao_driver_t *init_audio_out_plugin( config_values_t *config, xine_arts_audio *audio )
+xine_audio_port_t *init_audio_out_plugin( xine_t *xine, xine_arts_audio *audio )
 {
     fifo_driver_t *ao = (fifo_driver_t *)malloc( sizeof(fifo_driver_t) );
 
@@ -249,7 +290,7 @@
     ao->fifo_write_ptr	= 0;
     ao->bytes_in_buffer	= 0;
     ao->enabled		= 0;
-    ao->locked		= 0;
+    ao->close_delay	= 0;
     ao->capabilities	= (AO_CAP_MODE_MONO | AO_CAP_MODE_STEREO);
 
     ao->ao_driver.get_capabilities	= ao_fifo_get_capabilities;
@@ -266,32 +307,36 @@
     ao->ao_driver.control		= ao_fifo_control;
 
     pthread_cond_init( &ao->cond, NULL );
-    pthread_mutex_init( &ao->mutex, NULL );
+    pthread_mutex_init( &ao->read_mutex, NULL );
+    pthread_mutex_init( &ao->write_mutex, NULL );
 
-    return (ao_driver_t *)ao;
+    return ao_new_port( xine, (ao_driver_t *)ao );
 }
 
-unsigned long ao_fifo_read( ao_driver_t *this_gen, unsigned char **buffer,
+unsigned long ao_fifo_read( xine_audio_port_t *ao_port, unsigned char **buffer,
 			    unsigned long samples )
 {
-    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
+    fifo_driver_t *ao = (fifo_driver_t *)ao_port->driver;
     uint32_t r, m, n, a;
 
-    /* lock audio, return on audio disabled */
-    pthread_mutex_lock( &ao->mutex );
+    /* lock read buffer */
+    pthread_mutex_lock( &ao->read_mutex );
+    pthread_mutex_lock( &ao->write_mutex );
 
     if (!ao->enabled || !ao->bytes_in_buffer)
     {
-	if (ao->locked)
-	{
-	    ao->locked = 0;
-	    pthread_cond_broadcast( &ao->cond );
-	}
-	pthread_mutex_unlock( &ao->mutex );
+	/* signal blocked writes */
+	pthread_cond_broadcast( &ao->cond );
+	pthread_mutex_unlock( &ao->write_mutex );
+
+	/* unlock read buffer */
+	pthread_mutex_unlock( &ao->read_mutex );
+
+	/* audio FIFO empty or disabled, return */
 	return 0;
     }
-    ao->locked = 1;
-    pthread_mutex_unlock( &ao->mutex );
+
+    pthread_mutex_unlock( &ao->write_mutex );
 
     r = ao->fifo_read_ptr;
     m = (ao->buffer_size - r);
@@ -300,7 +345,7 @@
 
     if (n > a)
     {
-	fprintf( stderr, "Warning: Sound Buffer Underflow!\n" );
+	fprintf( stderr, "fifo_audio_out: audio buffer underflow!\n" );
 	n = a;
     }
     if (n > m)
@@ -308,60 +353,57 @@
 	/* copy samples from front to end of buffer */
 	memcpy( ao->fifo + ao->buffer_size, ao->fifo, (n - m) );
     }
+
+    /* return pointer to audio samples */
     *buffer = (ao->fifo + r);
+
     return n;
 }
 
-void ao_fifo_flush( ao_driver_t *this_gen, unsigned long samples )
+void ao_fifo_flush( xine_audio_port_t *ao_port, unsigned long samples )
 {
-    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
+    fifo_driver_t *ao = (fifo_driver_t *)ao_port->driver;
     uint32_t r, m, n, a;
 
-    pthread_mutex_lock( &ao->mutex );
+    pthread_mutex_lock( &ao->write_mutex );
 
-    if (ao->enabled)
-    {
-	r = ao->fifo_read_ptr;
-	m = (ao->buffer_size - r);
-	n = (samples * ao->bytes_per_frame);
-	a = ao->bytes_in_buffer;
-
-	if (n > a)
-	    n = a;
+    /* flush audio data */
+    r = ao->fifo_read_ptr;
+    m = (ao->buffer_size - r);
+    n = (samples * ao->bytes_per_frame);
+    a = ao->bytes_in_buffer;
+
+    if (n > a)
+	n = a;
 
-	a -= n;
-	r += n;
+    a -= n;
+    r += n;
 
-	if (r >= ao->buffer_size)
-	    r -= ao->buffer_size;
+    if (r >= ao->buffer_size)
+	r -= ao->buffer_size;
 
-	ao->fifo_read_ptr = r;
-	ao->bytes_in_buffer = a;
-    }
-    ao->locked = 0;
+    ao->fifo_read_ptr   = r;
+    ao->bytes_in_buffer = a;
+
+    /* signal blocked writes */
     pthread_cond_broadcast( &ao->cond );
-    pthread_mutex_unlock( &ao->mutex );
+    pthread_mutex_unlock( &ao->write_mutex );
+
+    /* unlock read buffer */
+    pthread_mutex_unlock( &ao->read_mutex );
 }
 
-void ao_fifo_wait_close( ao_driver_t *this_gen )
+void ao_fifo_disable( xine_ao_driver_t *ao_port )
 {
-    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
-
-    pthread_mutex_lock( &ao->mutex );
-    ao->enabled = 0;
-    pthread_cond_broadcast( &ao->cond );
-    pthread_mutex_unlock( &ao->mutex );
+    fifo_driver_t *ao = (fifo_driver_t *)ao_port->driver;
 
-    while (ao->locked)
-    {
-	struct timespec ts;
+    pthread_mutex_lock( &ao->write_mutex );
 
-	ts.tv_sec = 0;
-	ts.tv_nsec = 50000000;	/* 50ms */
+    /* disable audio driver */
+    ao->enabled = 0;
+    ao->close_delay = 0;
 
-	nanosleep( &ts, NULL );
-	pthread_mutex_lock( &ao->mutex );
-	pthread_cond_broadcast( &ao->cond );
-	pthread_mutex_unlock( &ao->mutex );
-    }
+    /* signal blocked writes */
+    pthread_cond_broadcast( &ao->cond );
+    pthread_mutex_unlock( &ao->write_mutex );
 }
diff -urN kdemultimedia-3.1/xine_artsplugin.old/audio_fifo_out.h kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.h
--- kdemultimedia-3.1/xine_artsplugin.old/audio_fifo_out.h	Thu Jun  6 12:42:13 2002
+++ kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.h	Thu Dec  5 21:10:14 2002
@@ -11,6 +11,8 @@
 #ifndef __AUDIO_FIFO_OUT_H
 #define __AUDIO_FIFO_OUT_H
 
+#include <xine.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -23,16 +25,16 @@
 } xine_arts_audio;
 
 
-ao_driver_t *init_audio_out_plugin( config_values_t *config, xine_arts_audio *audio );
+xine_audio_port_t *init_audio_out_plugin( xine_t *xine, xine_arts_audio *audio );
 
 int ao_fifo_arts_delay();
 
-unsigned long ao_fifo_read( ao_driver_t *this_gen, unsigned char **buffer,
+unsigned long ao_fifo_read( xine_audio_port_t *ao_port, unsigned char **buffer,
 			    unsigned long samples );
 
-void ao_fifo_flush( ao_driver_t *ao, unsigned long samples );
+void ao_fifo_flush( xine_audio_port_t *ao_port, unsigned long samples );
 
-void ao_fifo_wait_close( ao_driver_t *this_gen );
+void ao_fifo_disable( xine_audio_port_t *ao_port );
 
 #ifdef __cplusplus
 }
diff -urN kdemultimedia-3.1/xine_artsplugin.old/configure.in.in kdemultimedia-3.1/xine_artsplugin/configure.in.in
--- kdemultimedia-3.1/xine_artsplugin.old/configure.in.in	Sun Oct 27 00:20:56 2002
+++ kdemultimedia-3.1/xine_artsplugin/configure.in.in	Thu Dec  5 21:10:14 2002
@@ -23,11 +23,10 @@
 dnl distribution terms that you use for the rest of that program.
 dnl  
 
-dnl AC_PATH_XINE([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
-dnl Test for XINE, and define XINE_CFLAGS, XINE_INCS, and XINE_LIBS
+dnl AM_PATH_XINE([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
+dnl Test for XINE, and define XINE_CFLAGS and XINE_LIBS
 dnl
-
-AC_DEFUN([AC_PATH_XINE],
+AC_DEFUN([AM_PATH_XINE],
 [dnl 
 dnl Get the cflags and libraries from the xine-config script
 dnl
@@ -63,25 +62,23 @@
     if test "$XINE_CONFIG" = "no" ; then
       no_xine=yes
     else
-      _XINE_CFLAGS=`$XINE_CONFIG $xine_config_args --cflags`
-      XINE_CFLAGS=`echo ${_XINE_CFLAGS} | tr ' ' '\n' | grep -v -- ^-I`
-      XINE_INCS=`echo ${_XINE_CFLAGS} | tr ' ' '\n' | grep -- ^-I`
+      XINE_CFLAGS=`$XINE_CONFIG $xine_config_args --cflags`
       XINE_LIBS=`$XINE_CONFIG $xine_config_args --libs`
+      XINE_ACFLAGS=`$XINE_CONFIG $xine_config_args --acflags`
       xine_config_major_version=`$XINE_CONFIG $xine_config_args --version | \
              sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
       xine_config_minor_version=`$XINE_CONFIG $xine_config_args --version | \
              sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
       xine_config_sub_version=`$XINE_CONFIG $xine_config_args --version | \
              sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-      xine_skin_dir=`$XINE_CONFIG $xine_config_args --skindir`
+      xine_data_dir=`$XINE_CONFIG $xine_config_args --datadir`
       xine_script_dir=`$XINE_CONFIG $xine_config_args --scriptdir`
-      xine_desktop_dir=`$XINE_CONFIG $xine_config_args --desktopdir`
       xine_plugin_dir=`$XINE_CONFIG $xine_config_args --plugindir`
       xine_locale_dir=`$XINE_CONFIG $xine_config_args --localedir`
       dnl    if test "x$enable_xinetest" = "xyes" ; then
       ac_save_CFLAGS="$CFLAGS"
       ac_save_LIBS="$LIBS"
-      CFLAGS="$CFLAGS $XINE_CFLAGS $XINE_INCS"
+      CFLAGS="$CFLAGS $XINE_CFLAGS"
       LIBS="$XINE_LIBS $LIBS"
 dnl
 dnl Now check if the installed XINE is sufficiently new. (Also sanity
@@ -200,17 +197,16 @@
         fi
       fi
     XINE_CFLAGS=""
-    XINE_INCS=""
     XINE_LIBS=""
     ifelse([$3], , :, [$3])
   fi
   AC_SUBST(XINE_CFLAGS)
-  AC_SUBST(XINE_INCS)
   AC_SUBST(XINE_LIBS)
+  AC_SUBST(XINE_ACFLAGS)
   AC_LANG_RESTORE()
   rm -f conf.xinetest
 ])
-AC_PATH_XINE(0.9.9,, 
+AM_PATH_XINE(1.0.0,,
 [
   DO_NOT_COMPILE="$DO_NOT_COMPILE xine_artsplugin"
 ])
diff -urN kdemultimedia-3.1/xine_artsplugin.old/xinePlayObject_impl.cpp kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.cpp
--- kdemultimedia-3.1/xine_artsplugin.old/xinePlayObject_impl.cpp	Fri Nov 22 20:42:23 2002
+++ kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.cpp	Thu Dec  5 21:10:14 2002
@@ -15,62 +15,174 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <inttypes.h>
-#include <limits.h>
+#include <strings.h>
 #include <math.h>
 #include <audiosubsys.h>
 #include <convert.h>
 #include <debug.h>
+#include <iostream>
+
 #include "xinePlayObject_impl.h"
 
-#define VPO_PLAY		1000
-#define VPO_QUIT		1001
-#define VPO_STOP		1002
+#define TIMEOUT		15	// 15 seconds
 
 using namespace Arts;
 
 
+// Global xine pointer
+static xine_t		*xine_shared	 = NULL;
+static pthread_mutex_t	 xine_mutex	 = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t	 xine_cond	 = PTHREAD_COND_INITIALIZER;
+static int		 xine_count	 = 0;
+static bool		 xine_force_xshm = false;
+
+static void xine_init_routine()
+{
+    xine_cfg_entry_t cfg_entry;
+    char msg[1024];
+
+    xine_shared = (xine_t *)xine_new();
+
+    snprintf( msg, 1024, "%s/.xine/config", getenv( "HOME" ) );
+
+    xine_config_load( xine_shared, (char *)msg );
+
+    // Get default video output driver
+    if (xine_config_lookup_entry( xine_shared, "video.driver", &cfg_entry ))
+    {
+	xine_force_xshm = !strcasecmp( cfg_entry.str_value, "XShm" );
+    }
+    else
+    {
+	xine_force_xshm = false;
+    }
+
+    xine_init( xine_shared );
+}
+
+static void *xine_timeout_routine( void * )
+{
+    pthread_mutex_lock( &xine_mutex );
+
+    while (xine_shared != 0)
+    {
+	if (xine_count == 0)
+	{
+	    struct timespec ts;
+	    struct timeval tv;
+
+	    gettimeofday( &tv, 0 );
+
+	    ts.tv_sec	= tv.tv_sec;
+	    ts.tv_nsec	= tv.tv_usec * 1000;
+	    ts.tv_sec  += TIMEOUT;
+
+	    if (pthread_cond_timedwait( &xine_cond, &xine_mutex, &ts ) != 0 && xine_count == 0)
+	    {
+		xine_exit( xine_shared );
+		xine_shared = NULL;
+		break;
+	    }
+	}
+	else
+	{
+	    pthread_cond_wait( &xine_cond, &xine_mutex );
+	}
+    }
+
+    pthread_mutex_unlock( &xine_mutex );
+
+    return NULL;
+}
+
+static xine_t *xine_shared_init()
+{
+    pthread_mutex_lock( &xine_mutex );
+
+    ++xine_count;
+
+    if (xine_shared == 0)
+    {
+	pthread_t thread;
+
+	xine_init_routine();
+
+	if (pthread_create( &thread, NULL, xine_timeout_routine, NULL ) == 0)
+	{
+	    pthread_detach( thread );
+	}
+    }
+    else
+    {
+	pthread_cond_signal( &xine_cond );
+    }
+    pthread_mutex_unlock( &xine_mutex );
+
+    return xine_shared;
+}
+
+static void xine_shared_exit( xine_t * )
+{
+    pthread_mutex_lock( &xine_mutex );
+
+    if (--xine_count == 0)
+    {
+	pthread_cond_signal( &xine_cond );
+    }
+    pthread_mutex_unlock( &xine_mutex );
+}
+
 int ao_fifo_arts_delay()
 {
     return (int)(1000 * Arts::AudioSubSystem::the()->outputDelay());
 }
 
 xinePlayObject_impl::xinePlayObject_impl()
+    : mrl( "" ), xine( 0 ), stream( 0 ), queue( 0 ), ao_port( 0 ), vo_port( 0 )
 {
     XInitThreads();
 
-    if (!(video.display = XOpenDisplay( NULL )))
+    if (!(display = XOpenDisplay( NULL )))
     {
 	arts_fatal( "could not open X11 display" );
     }
 
-    XFlush( video.display );
+    XFlush( display );
 
     // Create a special window for uninterrupted X11 communication
-    video.xcom_window = XCreateSimpleWindow( video.display,
-					     DefaultRootWindow( video.display ),
-					     0, 0, 1, 1, 0, 0, 0 );
+    xcom_window = XCreateSimpleWindow( display, DefaultRootWindow( display ),
+				       0, 0, 1, 1, 0, 0, 0 );
 
-    XSelectInput( video.display, video.xcom_window, ExposureMask );
+    XSelectInput( display, xcom_window, ExposureMask );
 
-    pthread_cond_init( &cond, 0 );
     pthread_mutex_init( &mutex, 0 );
 
-    flpos		  = 0.0;
-    config		  = 0;
-    xine		  = 0;
-    ao_driver		  = 0;
-    vo_driver		  = 0;
+    // Initialize X11 properties
+    xcom_atom		   = XInternAtom( display, "VPO_INTERNAL_EVENT", False );
+    xcom_resize		   = XInternAtom( display, "VPO_RESIZE_NOTIFY", False );
+    screen		   = DefaultScreen( display );
+    shm_completion	   = (XShmQueryExtension( display ) == True)
+			     ? XShmGetEventBase( display ) + ShmCompletion : -1;
+    display_ratio	   = (double)(DisplayWidth( display, screen ) *
+				      DisplayHeightMM( display, screen ))
+				   / (DisplayWidthMM( display, screen ) *
+				      DisplayHeight( display, screen ));
+
+    // Initialize xine visual structure
+    visual.display	   = display;
+    visual.screen	   = screen;
+    visual.d		   = xcom_window;
+    visual.dest_size_cb	   = &dest_size_cb;
+    visual.frame_output_cb = &frame_output_cb;
+    visual.user_data	   = this;
 
     // Initialize audio and video details
     Arts::SoundServerV2 server = Arts::Reference( "global:Arts_SoundServerV2" );
-    audio.sample_rate	  = 0;
-    audio.num_channels	  = 0;
-    audio.bits_per_sample = 0;
-
-    video.xcom_atom	  = XInternAtom( video.display, "VPO_INTERNAL_EVENT", False );
-    video.xcom_resize	  = XInternAtom( video.display, "VPO_RESIZE_NOTIFY", False );
-    video.window	  = video.xcom_window;
+    audio.sample_rate	   = 0;
+    audio.num_channels	   = 0;
+    audio.bits_per_sample  = 0;
+
+    flpos		   = 0.0;
 
     if (pthread_create( &thread, 0, pthread_start_routine, this ))
     {
@@ -80,28 +192,137 @@
 
 xinePlayObject_impl::~xinePlayObject_impl()
 {
+    XEvent event;
+
     halt();
 
-    // Send stop event to thread
-    sendEvent( video.xcom_window, VPO_QUIT );
+    // Send stop event to thread (X11 client message)
+    memset( &event, 0, sizeof(event) );
+
+    event.type			= ClientMessage;
+    event.xclient.window	= xcom_window;
+    event.xclient.message_type	= xcom_atom;
+    event.xclient.format	= 32;
+
+    XSendEvent( display, xcom_window, True, 0, &event );
+
+    XFlush( display );
 
+    // Wait for the thread to die
     pthread_join( thread, 0 );
-    pthread_cond_destroy( &cond );
+
+    // Destroy stream, xine and related resources
+    if (stream != 0)
+    {
+	halt();
+
+	xine_event_dispose_queue( queue );
+	xine_dispose( stream );
+    }
+    if (xine != 0)
+    {
+	xine_shared_exit( xine );
+    }
+
     pthread_mutex_destroy( &mutex );
 
-    XSync( video.display, False );
-    XDestroyWindow( video.display, video.xcom_window );
-    XCloseDisplay( video.display );
+    XSync( display, False );
+    XDestroyWindow( display, xcom_window );
+    XCloseDisplay( display );
 }
 
 bool xinePlayObject_impl::loadMedia( const string &filename )
 {
-    halt();
+    bool result = false;
+
+    pthread_mutex_lock( &mutex );
+
+    mrl = "";
+
+    if (stream == 0)
+    {
+	if (xine == 0)
+	{
+	    xine = xine_shared_init();
+	}
+
+	ao_port = init_audio_out_plugin( xine, &audio );
+
+	width = 0;
+	height = 0;
+	ds_counter = 0;
+
+	if (xine_force_xshm)
+	{
+	    vo_port = xine_open_video_driver( xine, "XShm",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (vo_port == 0)
+	{
+	    vo_port = xine_open_video_driver( xine, "Xv",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (vo_port == 0)
+	{
+	    vo_port = xine_open_video_driver( xine, "XShm",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (vo_port == 0)
+	{
+	    vo_port = xine_open_video_driver( xine, "OpenGL",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (ao_port != 0 && vo_port != 0)
+	{
+	    stream = xine_stream_new( xine, ao_port, vo_port );
+
+	    if (stream != 0)
+	    {
+		xine_set_param( stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL, 0 );
+		xine_set_param( stream, XINE_PARAM_SPU_CHANNEL, -1 );
+
+		queue = xine_event_new_queue( stream );
+		xine_event_create_listener_thread( queue, xine_handle_event, this );
+	    }
+	}
+	if (stream == 0)
+	{
+	    if (ao_port != 0)
+	    {
+		xine_close_audio_driver( xine, ao_port );
+		ao_port = 0;
+	    }
+	    if (vo_port != 0)
+	    {
+		xine_close_video_driver( xine, vo_port );
+		vo_port = 0;
+	    }
+	}
+    }
 
-    // TODO: Should we protect this with a mutex?
-    mrl = filename;
+    if (stream != 0)
+    {
+	if (xine_get_status( stream ) == XINE_STATUS_PLAY)
+	{
+	    ao_fifo_disable( ao_port );
 
-    return true; //running;
+	    xine_stop( stream );
+
+	    clearWindow();
+	}
+	if ((result = xine_open( stream, filename.c_str() )))
+	{
+	    mrl = filename;
+	}
+    }
+
+    pthread_mutex_unlock( &mutex );
+
+    return result;
 }
 
 string xinePlayObject_impl::description()
@@ -112,11 +333,22 @@
 poTime xinePlayObject_impl::currentTime()
 {
     poTime time;
+    int pos_time;
 
     pthread_mutex_lock( &mutex );
 
-    time.seconds = (xine == 0) ? 0 : (long)xine_get_current_time( xine );
-    time.ms = 0;
+    if (stream != 0 && mrl != "")
+    {
+	xine_get_pos_length( stream, 0, &pos_time, 0 );
+
+	time.seconds = pos_time / 1000;
+	time.ms = pos_time % 1000;
+    }
+    else
+    {
+	time.seconds = 0;
+	time.ms = 0;
+    }
 
     pthread_mutex_unlock( &mutex );
 
@@ -126,19 +358,30 @@
 poTime xinePlayObject_impl::overallTime()
 {
     poTime time;
+    int length_time;
 
     pthread_mutex_lock( &mutex );
 
-    time.seconds = (xine == 0) ? 0 : (long)xine_get_stream_length( xine );
-    time.ms = 0;
+    if (stream != 0 && mrl != "")
+    {
+	xine_get_pos_length( stream, 0, 0, &length_time );
 
-    pthread_mutex_unlock( &mutex );
+	if (length_time <= 0)
+	{
+	    length_time = 1;
+	}
 
-    if (!time.seconds && !time.ms)
+	time.seconds = length_time / 1000;
+	time.ms = length_time % 1000;
+    }
+    else
     {
+	time.seconds = 0;
 	time.ms = 1;
     }
 
+    pthread_mutex_unlock( &mutex );
+
     return time;
 }
 
@@ -158,9 +401,9 @@
 
     pthread_mutex_lock( &mutex );
 
-    if ((xine == 0) || xine_get_status( xine ) != XINE_PLAY)
+    if (stream == 0 || xine_get_status( stream ) != XINE_STATUS_PLAY)
 	state = posIdle;
-    else if (xine_get_speed( xine ) == SPEED_PAUSE)
+    else if (xine_get_param( stream, XINE_PARAM_SPEED ) == XINE_SPEED_PAUSE)
 	state = posPaused;
     else
 	state = posPlaying;
@@ -176,9 +419,10 @@
 
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && xine_get_status( xine ) == XINE_PLAY)
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	pixmap = (long)vo_fifo_snapshot( &video, xine );
+	// FIXME: snapshot...
+	pixmap = (long)-1;
     }
     pthread_mutex_unlock( &mutex );
 
@@ -191,60 +435,53 @@
 
     if (window == -1)
     {
-	window = video.xcom_window;
+	window = xcom_window;
     }
 
-    if ((Window)window != video.window)
+    if ((Window)window != visual.d)
     {
-	XLockDisplay( video.display );
+	XLockDisplay( display );
 
 	// Change window and set event mask of new window
-	video.window = window;
+	visual.d = window;
 
-	XSelectInput( video.display, window, ExposureMask );
+	XSelectInput( display, window, ExposureMask );
 
-	if (vo_driver)
+	if (stream != 0)
 	{
-	    vo_fifo_resize_notify( &video );
-	    vo_driver->gui_data_exchange( vo_driver,
-					  GUI_DATA_EX_DRAWABLE_CHANGED,
-					  (void *)video.window );
+	    resizeNotify();
+	    xine_gui_send_vo_data( stream,
+				   XINE_GUI_SEND_DRAWABLE_CHANGED,
+				   (void *)window );
 	}
 
-	XUnlockDisplay( video.display );
+	XUnlockDisplay( display );
     }
     pthread_mutex_unlock( &mutex );
 }
 
 long xinePlayObject_impl::x11WindowId()
 {
-    return (video.window == video.xcom_window) ? (long)-1 : video.window;
+    return (visual.d == xcom_window) ? (long)-1 : visual.d;
 }
 
 void xinePlayObject_impl::play()
 {
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && xine_get_status( xine ) == XINE_PLAY)
+    if (stream != 0)
     {
-	if (xine_get_speed( xine ) == SPEED_PAUSE)
+	if (xine_get_status( stream ) == XINE_STATUS_PLAY)
 	{
-	    xine_set_speed( xine, SPEED_NORMAL );
+	    if (xine_get_param( stream, XINE_PARAM_SPEED ) == XINE_SPEED_PAUSE)
+	    {
+	        xine_set_param( stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL );
+	    }
 	}
-    }
-    else
-    {
-	// Wait for the xine object to be destroyed
-	while (xine != 0)
+	else if (mrl != "")
 	{
-	    pthread_cond_wait( &cond, &mutex );
+	    xine_play( stream, 0, 0 );
 	}
-
-	// Send play event
-	sendEvent( video.xcom_window, VPO_PLAY );
-
-	// Wait for the xine object to start (or fail)
-	pthread_cond_wait( &cond, &mutex );
     }
     pthread_mutex_unlock( &mutex );
 }
@@ -253,19 +490,13 @@
 {
     pthread_mutex_lock( &mutex );
 
-    if (xine != 0)
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	if (xine_get_status( xine ) == XINE_PLAY)
-	{
-	    ao_fifo_wait_close( ao_driver );
-
-	    xine_stop( xine );
-	}
+	ao_fifo_disable( ao_port );
 
-	sendEvent( video.xcom_window, VPO_STOP );
+	xine_stop( stream );
 
-	// Wait for the xine object to be destroyed
-	pthread_cond_wait( &cond, &mutex );
+	clearWindow();
     }
     pthread_mutex_unlock( &mutex );
 }
@@ -274,17 +505,15 @@
 {
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && (xine_get_status( xine ) == XINE_PLAY))
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	int paused = (xine_get_speed( xine ) == SPEED_PAUSE);
-
-	ao_fifo_flush( ao_driver, ULONG_MAX );
+	int paused = (xine_get_param( stream, XINE_PARAM_SPEED ) == XINE_SPEED_PAUSE);
 
-	xine_play( xine, (char *)mrl.c_str(), 0, t.seconds );
+	xine_play( stream, 0, 1000*t.seconds + t.ms );
 
 	if (paused)
 	{
-	    xine_set_speed( xine, SPEED_PAUSE );
+	    xine_set_param( stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE );
 	}
     }
     pthread_mutex_unlock( &mutex );
@@ -294,11 +523,9 @@
 {
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && (xine_get_status( xine ) == XINE_PLAY))
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	xine_set_speed( xine, SPEED_PAUSE );
-
-	ao_fifo_flush( ao_driver, ULONG_MAX );
+	xine_set_param( stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE );
     }
     pthread_mutex_unlock( &mutex );
 }
@@ -311,21 +538,12 @@
 
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && (xine_get_status( xine ) == XINE_PLAY))
+    if (stream != 0)
     {
-	if (xine_get_speed( xine ) != SPEED_PAUSE)
-	{
-	    // Calculate resampling parameters
-	    speed = (double)audio.sample_rate / samplingRateFloat;
-	    xSamples = (unsigned int)((double)samples * speed + 8.0);
-
-	    received = ao_fifo_read( ao_driver, &buffer, xSamples );
-	}
-	else
-	{
-	    // Clear audio buffer
-	    ao_fifo_flush( ao_driver, ULONG_MAX );
-	}
+	// Calculate resampling parameters
+	speed = (double)audio.sample_rate / samplingRateFloat;
+	xSamples = (unsigned int)((double)samples * speed + 8.0);
+	received = ao_fifo_read( ao_port, &buffer, xSamples );
     }
 
     pthread_mutex_unlock( &mutex );
@@ -341,7 +559,7 @@
 	skip   = (int)floor( flpos );
 	skip   = (received < (xSamples - 8)) ? (xSamples - 8) : skip;
 	flpos  = flpos - floor( flpos );
-	ao_fifo_flush( ao_driver, skip );
+	ao_fifo_flush( ao_port, skip );
     }
     for (unsigned long i=converted; i < samples; i++)
     {
@@ -350,166 +568,163 @@
     }
 }
 
-void xinePlayObject_impl::playEvent()
+void xinePlayObject_impl::xineEvent( const xine_event_t *event )
 {
-    pthread_mutex_lock( &mutex );
+    if (event->type == XINE_EVENT_UI_PLAYBACK_FINISHED)
+    {
+	clearWindow();
+    }
+}
 
-    running   = false;
-    vo_driver = init_video_out_plugin( config, &video );
+void xinePlayObject_impl::clearWindow()
+{
+    Window root;
+    unsigned int u, w, h;
+    int x, y, screen;
 
-    if (vo_driver)
-    {
-	ao_driver = init_audio_out_plugin( config, &audio );
+    XLockDisplay( display );
 
-	xine = xine_init( vo_driver, ao_driver, config );
+    screen = DefaultScreen( display );
 
-	xine_register_event_listener( xine, xine_handle_event, this );
-	xine_select_audio_channel( xine, 0 );
-	xine_select_spu_channel( xine, -1 );
+    XGetGeometry( display, visual.d, &root, &x, &y, &w, &h, &u, &u );
 
-	running = xine_play( xine, (char *)mrl.c_str(), 0, 0 );
+    XSetForeground( display, DefaultGC( display, screen ),
+		    BlackPixel( display, screen ) );
+    XFillRectangle( display, visual.d,
+		    DefaultGC( display, screen ), x, y, w, h );
 
-	if (!running)
-	{
-	    sendEvent( video.xcom_window, VPO_STOP );
-	}
-    }
-    if (!vo_driver || running)
-    {
-	pthread_cond_broadcast( &cond );
-    }
-    pthread_mutex_unlock( &mutex );
+    XUnlockDisplay( display );
 }
 
-void xinePlayObject_impl::stopEvent()
+void xinePlayObject_impl::frameOutput( int video_width, int video_height,
+				       double video_pixel_aspect,
+				       int *dest_x, int *dest_y,
+				       int *dest_width, int *dest_height,
+				       double *dest_pixel_aspect,
+				       int *win_x, int *win_y )
 {
-    pthread_mutex_lock( &mutex );
+    Window child, root;
+    unsigned int u;
+    int n;
 
-    if (xine != 0)
-    {
-	ao_fifo_wait_close( ao_driver );
+    XLockDisplay( display );
 
-	xine_remove_event_listener( xine, xine_handle_event );
-	xine_exit( xine );
+    XGetGeometry( display, visual.d, &root, &n, &n,
+		  (unsigned int *)dest_width, (unsigned int *)dest_height,
+		  &u, &u );
 
-	xine	    = 0;
-	ao_driver   = 0;
-	vo_driver   = 0;
-    }
-    pthread_cond_broadcast( &cond );
-    pthread_mutex_unlock( &mutex );
+    XTranslateCoordinates( display, visual.d, root, 0, 0, win_x, win_y, &child );
 
-    clearWindow();
-}
+    *dest_x = 0;
+    *dest_y = 0;
+    *dest_pixel_aspect = display_ratio;
 
-void xinePlayObject_impl::xineEvent( xine_event_t *event )
-{
-    if (event->type == XINE_EVENT_PLAYBACK_FINISHED)
+    if (video_pixel_aspect >= display_ratio)
+	video_width  = (int)(((video_width * video_pixel_aspect)
+			      / display_ratio) + .5);
+    else
+	video_height = (int)(((video_height * display_ratio)
+			      / video_pixel_aspect) + .5);
+
+    if ((!ds_counter || (--ds_counter == 0)) &&
+        (video_width != width || video_height != height))
     {
-	sendEvent( video.xcom_window, VPO_STOP );
+	width  = video_width;
+	height = video_height;
+
+	resizeNotify();
     }
+    XUnlockDisplay( display );
 }
 
-void xinePlayObject_impl::sendEvent( long window, long message )
+void xinePlayObject_impl::destSize( int video_width, int video_height,
+				    double video_pixel_aspect,
+				    int *dest_width, int *dest_height,
+				    double *dest_pixel_aspect )
 {
-    XEvent event;
+    Window root;
+    unsigned int u;
+    int n;
 
-    // Send X11 client message
-    memset( &event, 0, sizeof(event) );
+    XLockDisplay( display );
 
-    event.type			= ClientMessage;
-    event.xclient.window	= window;
-    event.xclient.message_type	= video.xcom_atom;
-    event.xclient.format	= 32;
-    event.xclient.data.l[0]	= message;
+    XGetGeometry( display, visual.d, &root, &n, &n,
+		  (unsigned int *)dest_width, (unsigned int *)dest_height,
+		  &u, &u );
 
-    XSendEvent( video.display, window, True, 0, &event );
+    *dest_pixel_aspect = display_ratio;
 
-    XFlush( video.display );
+    if (video_pixel_aspect >= display_ratio)
+	video_width  = (int)(((video_width * video_pixel_aspect)
+			      / display_ratio) + .5);
+    else
+	video_height = (int)(((video_height * display_ratio)
+			      / video_pixel_aspect) + .5);
+
+    if (video_width != width || video_height != height)
+    {
+	width  = video_width;
+	height = video_height;
+
+	resizeNotify();
+    }
+    XUnlockDisplay( display );
+
+    // Reset 'seen dest_size_cb' counter
+    ds_counter = 25;
 }
 
-void xinePlayObject_impl::clearWindow()
+void xinePlayObject_impl::resizeNotify()
 {
-    Window root;
-    unsigned int u, w, h;
-    int x, y, screen;
-
-    XLockDisplay( video.display );
+    XEvent event;
 
-    screen = DefaultScreen( video.display );
+    // Resize notify signal for front-ends
+    memset( &event, 0, sizeof(event) );
 
-    XGetGeometry( video.display, video.window, &root, &x, &y, &w, &h, &u, &u );
+    event.type			= ClientMessage;
+    event.xclient.window	= visual.d;
+    event.xclient.message_type	= xcom_resize;
+    event.xclient.format	= 32;
+    event.xclient.data.l[0]	= width;
+    event.xclient.data.l[1]	= height;
 
-    XSetForeground( video.display, DefaultGC( video.display, screen ),
-		    BlackPixel( video.display, screen ) );
-    XFillRectangle( video.display, video.window,
-		    DefaultGC( video.display, screen ), x, y, w, h );
+    XSendEvent( display, visual.d, True, 0, &event );
 
-    XUnlockDisplay( video.display );
+    XFlush( display );
 }
 
 void xinePlayObject_impl::eventLoop()
 {
     XEvent event;
-    string config_file = string( getenv( "HOME" )).append( "/.xine/config" );
-
-    config = xine_config_file_init( (char *)config_file.c_str() );
-
-    // Disable OSD
-    config->register_bool( config, (char *)"misc.osd_display", 0,
-			   (char *)"disabled for KDE", 0, 0, 0 );
-    config->update_num( config, (char *)"misc.osd_display", 0 );
 
-    // Disable xine logo
-    config->register_string( config, (char *)"misc.logo_mrl", (char *)"",
-			     (char *)"disabled for KDE", 0, 0, 0 );
-    config->update_string( config, (char *)"misc.logo_mrl", (char *)"" );
-
-    while (config)
+    do
     {
-	XNextEvent( video.display, &event );
+	XNextEvent( display, &event );
 
 	if (event.type == Expose && event.xexpose.count == 0 &&
-	    event.xexpose.window == video.window)
+	    event.xexpose.window == visual.d)
 	{
-	    if (vo_driver)
+	    if (stream != 0)
 	    {
-		vo_driver->gui_data_exchange( vo_driver,
-					      GUI_DATA_EX_EXPOSE_EVENT,
-					      &event );
+		xine_gui_send_vo_data( stream,
+				       XINE_GUI_SEND_EXPOSE_EVENT,
+				       &event );
 	    }
 	    else
 	    {
 		clearWindow();
 	    }
 	}
-	else if (event.type == video.shm_completion && vo_driver)
-	{
-	    vo_driver->gui_data_exchange( vo_driver,
-					  GUI_DATA_EX_COMPLETION_EVENT,
-					  &event );
-	}
-
-	if (event.type == ClientMessage &&
-	    event.xclient.message_type == video.xcom_atom &&
-	    event.xclient.window == video.xcom_window)
+	else if (event.type == shm_completion && stream != 0)
 	{
-	    switch (event.xclient.data.l[0])
-	    {
-	    case VPO_QUIT:
-		// Destroy xine config object (signal quit)
-		config->dispose( config );
-		config = 0;
-		break;
-	    case VPO_PLAY:
-		playEvent();
-		break;
-	    case VPO_STOP:
-		stopEvent();
-		break;
-	    }
+	    xine_gui_send_vo_data( stream,
+				   XINE_GUI_SEND_COMPLETION_EVENT,
+				   &event );
 	}
     }
+    while (event.type != ClientMessage ||
+	   event.xclient.message_type != xcom_atom ||
+	   event.xclient.window != xcom_window);
 }
 
 REGISTER_IMPLEMENTATION(xinePlayObject_impl);
diff -urN kdemultimedia-3.1/xine_artsplugin.old/xinePlayObject_impl.h kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.h
--- kdemultimedia-3.1/xine_artsplugin.old/xinePlayObject_impl.h	Sun Sep 15 23:14:53 2002
+++ kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.h	Thu Dec  5 21:10:14 2002
@@ -16,10 +16,10 @@
 #include <stdsynthmodule.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
+#include <X11/extensions/XShm.h>
 #include <xine.h>
-#include <xine/video_out_x11.h>
+
 #include "audio_fifo_out.h"
-#include "video_fifo_out.h"
 #include "xinePlayObject.h"
 
 
@@ -41,7 +41,6 @@
     poCapabilities capabilities();
     string mediaName();
     poState state();
-    bool snapshot( long pixmap );
     long x11Snapshot();
     long x11WindowId();
     void x11WindowId( long window );
@@ -52,11 +51,14 @@
     void calculateBlock( unsigned long samples );
 
 protected:
-    void playEvent();
-    void stopEvent();
-    void xineEvent( xine_event_t *event );
-    void sendEvent( long window, long message );
+    void xineEvent( const xine_event_t *event );
     void clearWindow();
+    void frameOutput( int video_width, int video_height, double video_pixel_aspect,
+		      int *dest_x, int *dest_y, int *dest_width, int *dest_height,
+		      double *dest_pixel_aspect, int *win_x, int *win_y );
+    void destSize( int video_width, int video_height, double video_pixel_aspect,
+		   int *dest_width, int *dest_height, double *dest_pixel_aspect );
+    void resizeNotify();
     void eventLoop();
 
     // C -> C++ wrapper for pthread API
@@ -67,26 +69,61 @@
     }
 
     // C -> C++ wrapper for xine API
-    static inline void xine_handle_event( void *user_data, xine_event_t *event )
+    static inline void xine_handle_event( void *user_data, const xine_event_t *event )
     {
 	((xinePlayObject_impl *)user_data)->xineEvent( event );
     }
 
+    // C -> C++ wrapper for xine API
+    static void frame_output_cb( void *user_data, int video_width,
+				 int video_height, double video_pixel_aspect,
+				 int *dest_x, int *dest_y, int *dest_width,
+				 int *dest_height, double *dest_pixel_aspect,
+				 int *win_x, int *win_y )
+    {
+	xinePlayObject_impl *xpo = (xinePlayObject_impl *)user_data;
+	xpo->frameOutput( video_width, video_height, video_pixel_aspect,
+			  dest_x, dest_y, dest_width, dest_height,
+			  dest_pixel_aspect, win_x, win_y );
+    }
+
+    // C -> C++ wrapper for xine API
+    static void dest_size_cb( void *user_data, int video_width, int video_height,
+			      double video_pixel_aspect, int *dest_width,
+			      int *dest_height, double *dest_pixel_aspect )
+    {
+	xinePlayObject_impl *xpo = (xinePlayObject_impl *)user_data;
+	xpo->destSize( video_width, video_height, video_pixel_aspect,
+		       dest_width, dest_height, dest_pixel_aspect );
+    }
+
 private:
-    double	     flpos;
-    string	     mrl;
-    bool	     running;
-
-    pthread_mutex_t  mutex;
-    pthread_cond_t   cond;
-    pthread_t	     thread;
-
-    config_values_t *config;
-    xine_t	    *xine;
-    ao_driver_t	    *ao_driver;
-    vo_driver_t	    *vo_driver;
-    xine_arts_audio  audio;
-    xine_arts_video  video;
+    double		 flpos;
+    string		 mrl;
+    string		 vo_driver_id;
+
+    pthread_mutex_t	 mutex;
+    pthread_t		 thread;
+
+    xine_t		*xine;
+    xine_stream_t	*stream;
+    xine_event_queue_t	*queue;
+    xine_audio_port_t	*ao_port;
+    xine_video_port_t	*vo_port;
+    x11_visual_t	 visual;
+    xine_arts_audio	 audio;
+
+    Display		*display;
+    Window		 xcom_window;
+    Atom		 xcom_atom;
+    Atom		 xcom_resize;
+    int			 screen;
+    int			 shm_completion;
+    double		 display_ratio;
+
+    int			 width;
+    int			 height;
+    int			 ds_counter;
 };
 
 #endif
