diff -urN kdemultimedia-3.1.orig/xine_artsplugin/Makefile.am kdemultimedia-3.1/xine_artsplugin/Makefile.am
--- kdemultimedia-3.1.orig/xine_artsplugin/Makefile.am	Sun Oct 27 00:20:56 2002
+++ kdemultimedia-3.1/xine_artsplugin/Makefile.am	Tue Jan 14 10:03:11 2003
@@ -1,13 +1,10 @@
-INCLUDES= -I$(kde_includes)/arts $(all_includes) $(XINE_INCS)
-
-AM_CFLAGS = -U__STRICT_ANSI__ $(XINE_CFLAGS)
+INCLUDES= -I$(kde_includes)/arts $(all_includes) $(XINE_CFLAGS)
 
 lib_LTLIBRARIES = libarts_xine.la
 
 libarts_xine_la_SOURCES = xinePlayObject.cc \
 			  xinePlayObject_impl.cpp \
-			  audio_fifo_out.c \
-			  video_fifo_out.c
+			  audio_fifo_out.c
 libarts_xine_la_LDFLAGS = $(all_libraries) -module -avoid-version -pthread
 libarts_xine_la_LIBADD = $(XINE_LIBS) $(LIB_X11) $(LIB_XEXT) \
 			 -lkmedia2_idl -lsoundserver_idl -lartsflow
@@ -18,9 +15,7 @@
 xinePlayObject.cc xinePlayObject.h: $(srcdir)/xinePlayObject.idl
 	$(MCOPIDL) $(INCLUDES) $(srcdir)/xinePlayObject.idl
 
-noinst_HEADERS = xinePlayObject_impl.h audio_fifo_out.h video_fifo_out.h
+noinst_HEADERS = xinePlayObject_impl.h audio_fifo_out.h
 
 mcopclassdir = $(libdir)/mcop
 mcopclass_DATA = xinePlayObject.mcopclass
-
-SUBDIRS = tools
diff -urN kdemultimedia-3.1.orig/xine_artsplugin/audio_fifo_out.c kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.c
--- kdemultimedia-3.1.orig/xine_artsplugin/audio_fifo_out.c	Fri Nov 22 20:42:23 2002
+++ kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.c	Tue Jan 14 10:03:11 2003
@@ -1,6 +1,6 @@
 /*
    This file is part of KDE/aRts (Noatun) - xine integration
-   Copyright (C) 2002 Ewald Snel <ewald@rambo.its.tudelft.nl>
+   Copyright (C) 2002-2003 Ewald Snel <ewald@rambo.its.tudelft.nl>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -16,10 +16,12 @@
 #include <stdlib.h>
 #include <string.h>
 #include <inttypes.h>
+#include <malloc.h>
 #include <pthread.h>
+#include <time.h>
 #include <sys/time.h>
-#include <xine/xine_internal.h>
 #include <xine/audio_out.h>
+
 #include "audio_fifo_out.h"
 
 #define GAP_TOLERANCE	5000
@@ -32,17 +34,17 @@
 
     int		     capabilities;
     int		     mode;
-    int		     enabled;
-    int		     locked;
-    pthread_mutex_t  mutex;
+    pthread_mutex_t  read_mutex;
+    pthread_mutex_t  write_mutex;
     pthread_cond_t   cond;
 
     uint32_t	     bytes_per_frame;
-    uint32_t	     bytes_in_buffer;
-    uint32_t	     buffer_size;
     uint8_t	    *fifo;
-    uint32_t	     fifo_read_ptr;
-    uint32_t	     fifo_write_ptr;
+    int		     fifo_size;
+    int		     fifo_read_ptr;
+    int		     fifo_write_ptr;
+    int		     fifo_flush;
+    int		     fifo_delay;
 } fifo_driver_t;
 
 /*
@@ -57,12 +59,13 @@
 	fprintf( stderr, "fifo_audio_out: unsupported mode %08x\n", mode);
 	return 0;
     }
+
+    /* lock read buffer */
+    pthread_mutex_lock( &ao->read_mutex );
+
     ao->mode			= mode;
     ao->audio->sample_rate	= rate;
     ao->audio->bits_per_sample	= bits;
-    ao->fifo_read_ptr		= 0;
-    ao->fifo_write_ptr		= 0;
-    ao->bytes_in_buffer		= 0;
 
     switch (mode)
     {
@@ -73,14 +76,17 @@
 	ao->audio->num_channels = 2;
 	break;
     }
+
     ao->bytes_per_frame	= (ao->audio->bits_per_sample * ao->audio->num_channels) / 8;
-    ao->buffer_size	= ao->audio->sample_rate * ao->bytes_per_frame;
-    ao->fifo		= malloc( (ao->buffer_size << 1) );
+    ao->fifo_size	= ao->audio->sample_rate * ao->bytes_per_frame;
+    ao->fifo		= malloc( 2*ao->fifo_size );
+    ao->fifo_read_ptr	= 0;
+    ao->fifo_write_ptr	= 0;
+    ao->fifo_flush	= 0;
+    ao->fifo_delay	= 0;
 
-    pthread_mutex_lock( &ao->mutex );
-    ao->enabled = 1;
-    ao->locked  = 0;
-    pthread_mutex_unlock( &ao->mutex );
+    /* unlock and enable read buffer for aRts sound server */
+    pthread_mutex_unlock( &ao->read_mutex );
 
     return ao->audio->sample_rate;
 }
@@ -100,83 +106,95 @@
     return GAP_TOLERANCE;
 }
 
+static int ao_fifo_bytes_in_buffer( fifo_driver_t *ao )
+{
+    int bytes_in_buffer = (ao->fifo_write_ptr - ao->fifo_read_ptr);
+
+    if (bytes_in_buffer < 0)
+    {
+	bytes_in_buffer += ao->fifo_size;
+    }
+    return bytes_in_buffer;
+}
+
 static int ao_fifo_write( ao_driver_t *this_gen, int16_t *data, uint32_t num_frames )
 {
     fifo_driver_t *ao = (fifo_driver_t *)this_gen;
-    uint32_t w, n, m;
     uint8_t *src = (uint8_t *)data;
+    int bytes_in_buffer, bytes_to_write, written;
 
-    w = ao->fifo_write_ptr;
-    n = (num_frames * ao->bytes_per_frame);
-    m = (ao->buffer_size - w);
+    bytes_to_write = (num_frames * ao->bytes_per_frame);
 
-    if (n > ao->buffer_size)
-    {
-	/* split audio packet into 2 fragments */
-	n    = (num_frames >> 1);
-	src += (n * ao->bytes_per_frame);
+    pthread_mutex_lock( &ao->write_mutex );
 
-	return  ao_fifo_write( this_gen, data, n ) &&
-		ao_fifo_write( this_gen, (int16_t *)src, n + (num_frames & 1) );
-    }
-    if ((ao->bytes_in_buffer + n) > ao->buffer_size)
+    while (!ao->fifo_flush && bytes_to_write > 0)
     {
-	pthread_mutex_lock( &ao->mutex );
+	bytes_in_buffer = ao_fifo_bytes_in_buffer( ao );
+	written = bytes_to_write;
 
-	while ((ao->bytes_in_buffer + n) > ao->buffer_size)
+	if ((bytes_in_buffer + written) >= ao->fifo_size)
 	{
-	    struct timespec ts;
-	    struct timeval tv;
-	    int delay;
+	    written  = (ao->fifo_size - bytes_in_buffer - 1);
+	    written -= (written % ao->bytes_per_frame);
 
-	    if (!ao->enabled)
+	    if (written == 0)
 	    {
-		/* audio has stopped */
-		pthread_mutex_unlock( &ao->mutex );
-		return 0;
+		struct timespec ts;
+		struct timeval tv;
+		int delay;
+
+		gettimeofday( &tv, 0 );
+
+		delay  = ao_fifo_arts_delay();
+		delay += (1000 * num_frames) / ao->audio->sample_rate;
+		delay  = (delay < 20) ? 20 : ((delay >= 250) ? 250 : delay + 1);
+
+		ts.tv_sec  = tv.tv_sec + (delay / 1000);
+		ts.tv_nsec = (1000 * tv.tv_usec) + (1000000 * (delay % 1000));
+
+		if (ts.tv_nsec >= 1000000000)
+		{
+		    ts.tv_sec++;
+		    ts.tv_nsec -= 1000000000;
+		}
+		if (pthread_cond_timedwait( &ao->cond, &ao->write_mutex, &ts ) != 0)
+		{
+		    fprintf( stderr, "fifo_audio_out: blocked for more than %d ms,\n", delay);
+		    fprintf( stderr, "fifo_audio_out: %d sample(s) discarded.\n", num_frames);
+		    pthread_mutex_unlock( &ao->write_mutex );
+		    return 0;
+		}
 	    }
+	}
 
-	    gettimeofday( &tv, 0 );
-
-	    ts.tv_sec	= tv.tv_sec;
-	    ts.tv_nsec	= tv.tv_usec * 1000;
-
-	    delay	= ao_fifo_arts_delay();
-	    delay      += (1000 * num_frames) / ao->audio->sample_rate;
-	    delay	= (delay < 20) ? 20 : ((delay >= 250) ? 250 : delay + 1);
-	    ts.tv_sec  += delay / 1000;
-	    ts.tv_nsec += 1000000 * (delay % 1000);
+	if (!ao->fifo_flush && written > 0)
+	{
+	    int new_write_ptr = (ao->fifo_write_ptr + written);
 
-	    if (ts.tv_nsec >= 1000000000)
+	    if (new_write_ptr >= ao->fifo_size)
 	    {
-		ts.tv_sec++;
-		ts.tv_nsec -= 1000000000;
+		new_write_ptr -= ao->fifo_size;
+
+		memcpy( &ao->fifo[ao->fifo_write_ptr], src, (written - new_write_ptr) );
+		memcpy( ao->fifo, &src[written - new_write_ptr], new_write_ptr );
 	    }
-	    if (pthread_cond_timedwait( &ao->cond, &ao->mutex, &ts ) != 0)
+	    else
 	    {
-		fprintf( stderr, "fifo_audio_out: blocked for more than %d ms,\n", delay);
-		fprintf( stderr, "fifo_audio_out: %d sample(s) discarded.\n", num_frames);
-		pthread_mutex_unlock( &ao->mutex );
-		return 0;
+		memcpy( &ao->fifo[ao->fifo_write_ptr], src, written );
 	    }
+
+	    /* update audio buffer pointer */
+	    ao->fifo_write_ptr = new_write_ptr;
+	    bytes_to_write -= written;
+	    src += written;
 	}
-	pthread_mutex_unlock( &ao->mutex );
-    }
-    if (n >= m)
-    {
-	memcpy( (ao->fifo + w), src, m );
-	w = (n - m);
-	memcpy( ao->fifo, src + m, w );
-    }
-    else
-    {
-	memcpy( (ao->fifo + w), src, n );
-	w += n;
     }
-    pthread_mutex_lock( &ao->mutex );
-    ao->fifo_write_ptr = w;
-    ao->bytes_in_buffer += n;
-    pthread_mutex_unlock( &ao->mutex );
+
+    /* audio has stopped */
+    ao->fifo_delay += bytes_to_write;
+
+    pthread_mutex_unlock( &ao->write_mutex );
+
     return 1;
 }
 
@@ -184,28 +202,27 @@
 {
     fifo_driver_t *ao = (fifo_driver_t *)this_gen;
     return (ao_fifo_arts_delay() * ao->audio->sample_rate / 1000)
-	   + (ao->bytes_in_buffer / ao->bytes_per_frame);
+	   + ((ao_fifo_bytes_in_buffer( ao ) + ao->fifo_delay) / ao->bytes_per_frame);
 }
 
 static void ao_fifo_close( ao_driver_t *this_gen )
 {
     fifo_driver_t *ao = (fifo_driver_t *)this_gen;
 
-    pthread_mutex_lock( &ao->mutex );
-
-    while (ao->bytes_in_buffer && ao->enabled)
-    {
-	pthread_cond_wait( &ao->cond, &ao->mutex );
-    }
-    pthread_mutex_unlock( &ao->mutex );
+    /* lock read buffer */
+    pthread_mutex_lock( &ao->read_mutex );
 
-    ao_fifo_wait_close( this_gen );
+    /* disable audio driver */
+    ao->fifo_flush = 2;
+    ao->fifo_delay = 0;
 
+    /* free audio FIFO */
     if (ao->fifo)
     {
 	free( ao->fifo );
 	ao->fifo = NULL;
     }
+    pthread_mutex_unlock( &ao->read_mutex );
 }
 
 static uint32_t ao_fifo_get_capabilities( ao_driver_t *this_gen )
@@ -220,7 +237,9 @@
     ao_fifo_close( this_gen );
 
     pthread_cond_destroy( &ao->cond );
-    pthread_mutex_destroy( &ao->mutex );
+    pthread_mutex_destroy( &ao->read_mutex );
+    pthread_mutex_destroy( &ao->write_mutex );
+
     free( ao );
 }
 
@@ -236,10 +255,34 @@
 
 static int ao_fifo_control( ao_driver_t *this_gen, int cmd, ... )
 {
+    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
+
+    switch (cmd)
+    {
+    case AO_CTRL_FLUSH_BUFFERS:
+    case AO_CTRL_PLAY_PAUSE:
+	/* flush audio FIFO */
+	pthread_mutex_lock( &ao->read_mutex );
+
+	ao->fifo_read_ptr = ao->fifo_write_ptr;
+
+	if (ao->fifo_flush == 1)
+	{
+	    ao->fifo_flush = 0;
+	    ao->fifo_delay = 0;
+	}
+	pthread_mutex_unlock( &ao->read_mutex );
+
+	break;
+
+    case AO_CTRL_PLAY_RESUME:
+	break;
+    }
     return 0;
 }
 
-ao_driver_t *init_audio_out_plugin( config_values_t *config, xine_arts_audio *audio )
+xine_audio_port_t *init_audio_out_plugin( xine_t *xine, xine_arts_audio *audio,
+					  void **ao_driver )
 {
     fifo_driver_t *ao = (fifo_driver_t *)malloc( sizeof(fifo_driver_t) );
 
@@ -247,9 +290,8 @@
     ao->fifo		= NULL;
     ao->fifo_read_ptr	= 0;
     ao->fifo_write_ptr	= 0;
-    ao->bytes_in_buffer	= 0;
-    ao->enabled		= 0;
-    ao->locked		= 0;
+    ao->fifo_flush	= 2;
+    ao->fifo_delay	= 0;
     ao->capabilities	= (AO_CAP_MODE_MONO | AO_CAP_MODE_STEREO);
 
     ao->ao_driver.get_capabilities	= ao_fifo_get_capabilities;
@@ -266,102 +308,101 @@
     ao->ao_driver.control		= ao_fifo_control;
 
     pthread_cond_init( &ao->cond, NULL );
-    pthread_mutex_init( &ao->mutex, NULL );
+    pthread_mutex_init( &ao->read_mutex, NULL );
+    pthread_mutex_init( &ao->write_mutex, NULL );
+
+    *ao_driver		= (void *)ao;
 
-    return (ao_driver_t *)ao;
+    return ao_new_port( xine, (ao_driver_t *)ao, 0 );
 }
 
-unsigned long ao_fifo_read( ao_driver_t *this_gen, unsigned char **buffer,
+unsigned long ao_fifo_read( void *ao_driver, unsigned char **buffer,
 			    unsigned long samples )
 {
-    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
-    uint32_t r, m, n, a;
+    fifo_driver_t *ao = (fifo_driver_t *)ao_driver;
+    int bytes_in_buffer, bytes_to_read;
+
+    /* lock read buffer */
+    pthread_mutex_lock( &ao->read_mutex );
 
-    /* lock audio, return on audio disabled */
-    pthread_mutex_lock( &ao->mutex );
+    bytes_in_buffer = ao_fifo_bytes_in_buffer( ao );
+    bytes_to_read   = (samples * ao->bytes_per_frame);
 
-    if (!ao->enabled || !ao->bytes_in_buffer)
+    if (ao->fifo_flush || bytes_in_buffer == 0)
     {
-	if (ao->locked)
-	{
-	    ao->locked = 0;
-	    pthread_cond_broadcast( &ao->cond );
-	}
-	pthread_mutex_unlock( &ao->mutex );
+	/* unlock read buffer */
+	pthread_mutex_unlock( &ao->read_mutex );
+
+	/* signal blocked writes */
+	pthread_mutex_lock( &ao->write_mutex );
+	pthread_cond_signal( &ao->cond );
+	pthread_mutex_unlock( &ao->write_mutex );
+
+	/* audio FIFO empty or disabled, return */
 	return 0;
     }
-    ao->locked = 1;
-    pthread_mutex_unlock( &ao->mutex );
 
-    r = ao->fifo_read_ptr;
-    m = (ao->buffer_size - r);
-    n = (samples * ao->bytes_per_frame);
-    a = ao->bytes_in_buffer;
-
-    if (n > a)
+    if (bytes_to_read > bytes_in_buffer)
     {
-	fprintf( stderr, "Warning: Sound Buffer Underflow!\n" );
-	n = a;
+	fprintf( stderr, "fifo_audio_out: audio buffer underflow!\n" );
+	bytes_to_read = bytes_in_buffer - (bytes_in_buffer % ao->bytes_per_frame);
     }
-    if (n > m)
+    if ((ao->fifo_read_ptr + bytes_to_read) > ao->fifo_size)
     {
 	/* copy samples from front to end of buffer */
-	memcpy( ao->fifo + ao->buffer_size, ao->fifo, (n - m) );
+	memcpy( &ao->fifo[ao->fifo_size], ao->fifo,
+		((ao->fifo_read_ptr + bytes_to_read) - ao->fifo_size) );
     }
-    *buffer = (ao->fifo + r);
-    return n;
+
+    /* return pointer to audio samples */
+    *buffer = &ao->fifo[ao->fifo_read_ptr];
+
+    return bytes_to_read;
 }
 
-void ao_fifo_flush( ao_driver_t *this_gen, unsigned long samples )
+void ao_fifo_flush( void *ao_driver, unsigned long samples )
 {
-    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
-    uint32_t r, m, n, a;
+    fifo_driver_t *ao = (fifo_driver_t *)ao_driver;
+    int bytes_in_buffer, bytes_to_flush;
 
-    pthread_mutex_lock( &ao->mutex );
+    /* flush audio data */
+    bytes_in_buffer = ao_fifo_bytes_in_buffer( ao );
+    bytes_to_flush  = (samples * ao->bytes_per_frame);
 
-    if (ao->enabled)
+    if (bytes_to_flush <= bytes_in_buffer)
     {
-	r = ao->fifo_read_ptr;
-	m = (ao->buffer_size - r);
-	n = (samples * ao->bytes_per_frame);
-	a = ao->bytes_in_buffer;
+	int new_read_ptr = (ao->fifo_read_ptr + bytes_to_flush);
 
-	if (n > a)
-	    n = a;
-
-	a -= n;
-	r += n;
+	if (new_read_ptr >= ao->fifo_size)
+	{
+	    new_read_ptr -= ao->fifo_size;
+	}
+	ao->fifo_read_ptr = new_read_ptr;
+    }
 
-	if (r >= ao->buffer_size)
-	    r -= ao->buffer_size;
+    /* unlock read buffer */
+    pthread_mutex_unlock( &ao->read_mutex );
 
-	ao->fifo_read_ptr = r;
-	ao->bytes_in_buffer = a;
-    }
-    ao->locked = 0;
-    pthread_cond_broadcast( &ao->cond );
-    pthread_mutex_unlock( &ao->mutex );
+    /* signal blocked writes */
+    pthread_mutex_lock( &ao->write_mutex );
+    pthread_cond_signal( &ao->cond );
+    pthread_mutex_unlock( &ao->write_mutex );
 }
 
-void ao_fifo_wait_close( ao_driver_t *this_gen )
+void ao_fifo_clear( void *ao_driver, int clear )
 {
-    fifo_driver_t *ao = (fifo_driver_t *)this_gen;
+    fifo_driver_t *ao = (fifo_driver_t *)ao_driver;
 
-    pthread_mutex_lock( &ao->mutex );
-    ao->enabled = 0;
-    pthread_cond_broadcast( &ao->cond );
-    pthread_mutex_unlock( &ao->mutex );
-
-    while (ao->locked)
-    {
-	struct timespec ts;
-
-	ts.tv_sec = 0;
-	ts.tv_nsec = 50000000;	/* 50ms */
-
-	nanosleep( &ts, NULL );
-	pthread_mutex_lock( &ao->mutex );
-	pthread_cond_broadcast( &ao->cond );
-	pthread_mutex_unlock( &ao->mutex );
+    pthread_mutex_lock( &ao->write_mutex );
+
+    /* enable/disable audio driver */
+    ao->fifo_flush = clear;
+    ao->fifo_delay = 0;
+
+    if (clear)
+    {
+	/* signal blocked writes */
+	pthread_cond_signal( &ao->cond );
     }
+    pthread_mutex_unlock( &ao->write_mutex );
 }
diff -urN kdemultimedia-3.1.orig/xine_artsplugin/audio_fifo_out.h kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.h
--- kdemultimedia-3.1.orig/xine_artsplugin/audio_fifo_out.h	Thu Jun  6 12:42:13 2002
+++ kdemultimedia-3.1/xine_artsplugin/audio_fifo_out.h	Tue Jan 14 10:03:11 2003
@@ -1,6 +1,6 @@
 /*
    This file is part of KDE/aRts (Noatun) - xine integration
-   Copyright (C) 2002 Ewald Snel <ewald@rambo.its.tudelft.nl>
+   Copyright (C) 2002-2003 Ewald Snel <ewald@rambo.its.tudelft.nl>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -11,6 +11,8 @@
 #ifndef __AUDIO_FIFO_OUT_H
 #define __AUDIO_FIFO_OUT_H
 
+#include <xine.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -23,16 +25,17 @@
 } xine_arts_audio;
 
 
-ao_driver_t *init_audio_out_plugin( config_values_t *config, xine_arts_audio *audio );
+xine_audio_port_t *init_audio_out_plugin( xine_t *xine, xine_arts_audio *audio,
+					  void **ao_driver );
 
 int ao_fifo_arts_delay();
 
-unsigned long ao_fifo_read( ao_driver_t *this_gen, unsigned char **buffer,
+unsigned long ao_fifo_read( void *ao_driver, unsigned char **buffer,
 			    unsigned long samples );
 
-void ao_fifo_flush( ao_driver_t *ao, unsigned long samples );
+void ao_fifo_flush( void *ao_driver, unsigned long samples );
 
-void ao_fifo_wait_close( ao_driver_t *this_gen );
+void ao_fifo_clear( void *ao_driver, int clear );
 
 #ifdef __cplusplus
 }
diff -urN kdemultimedia-3.1.orig/xine_artsplugin/configure.in.in kdemultimedia-3.1/xine_artsplugin/configure.in.in
--- kdemultimedia-3.1.orig/xine_artsplugin/configure.in.in	Sun Oct 27 00:20:56 2002
+++ kdemultimedia-3.1/xine_artsplugin/configure.in.in	Tue Jan 14 10:03:11 2003
@@ -23,11 +23,10 @@
 dnl distribution terms that you use for the rest of that program.
 dnl  
 
-dnl AC_PATH_XINE([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
-dnl Test for XINE, and define XINE_CFLAGS, XINE_INCS, and XINE_LIBS
+dnl AM_PATH_XINE([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
+dnl Test for XINE, and define XINE_CFLAGS and XINE_LIBS
 dnl
-
-AC_DEFUN([AC_PATH_XINE],
+AC_DEFUN([AM_PATH_XINE],
 [dnl 
 dnl Get the cflags and libraries from the xine-config script
 dnl
@@ -63,25 +62,23 @@
     if test "$XINE_CONFIG" = "no" ; then
       no_xine=yes
     else
-      _XINE_CFLAGS=`$XINE_CONFIG $xine_config_args --cflags`
-      XINE_CFLAGS=`echo ${_XINE_CFLAGS} | tr ' ' '\n' | grep -v -- ^-I`
-      XINE_INCS=`echo ${_XINE_CFLAGS} | tr ' ' '\n' | grep -- ^-I`
+      XINE_CFLAGS=`$XINE_CONFIG $xine_config_args --cflags`
       XINE_LIBS=`$XINE_CONFIG $xine_config_args --libs`
+      XINE_ACFLAGS=`$XINE_CONFIG $xine_config_args --acflags`
       xine_config_major_version=`$XINE_CONFIG $xine_config_args --version | \
              sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
       xine_config_minor_version=`$XINE_CONFIG $xine_config_args --version | \
              sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
       xine_config_sub_version=`$XINE_CONFIG $xine_config_args --version | \
              sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-      xine_skin_dir=`$XINE_CONFIG $xine_config_args --skindir`
+      xine_data_dir=`$XINE_CONFIG $xine_config_args --datadir`
       xine_script_dir=`$XINE_CONFIG $xine_config_args --scriptdir`
-      xine_desktop_dir=`$XINE_CONFIG $xine_config_args --desktopdir`
       xine_plugin_dir=`$XINE_CONFIG $xine_config_args --plugindir`
       xine_locale_dir=`$XINE_CONFIG $xine_config_args --localedir`
       dnl    if test "x$enable_xinetest" = "xyes" ; then
       ac_save_CFLAGS="$CFLAGS"
       ac_save_LIBS="$LIBS"
-      CFLAGS="$CFLAGS $XINE_CFLAGS $XINE_INCS"
+      CFLAGS="$CFLAGS $XINE_CFLAGS"
       LIBS="$XINE_LIBS $LIBS"
 dnl
 dnl Now check if the installed XINE is sufficiently new. (Also sanity
@@ -200,17 +197,20 @@
         fi
       fi
     XINE_CFLAGS=""
-    XINE_INCS=""
     XINE_LIBS=""
     ifelse([$3], , :, [$3])
   fi
   AC_SUBST(XINE_CFLAGS)
-  AC_SUBST(XINE_INCS)
   AC_SUBST(XINE_LIBS)
+  AC_SUBST(XINE_ACFLAGS)
   AC_LANG_RESTORE()
   rm -f conf.xinetest
+
+dnl Make sure HAVE_STRSEP, HAVE_SETENV and HAVE_STRPBRK are defined as
+dnl necessary.
+  AC_CHECK_FUNCS([strsep strpbrk setenv])
 ])
-AC_PATH_XINE(0.9.9,, 
+AM_PATH_XINE(1.0.0,,
 [
   DO_NOT_COMPILE="$DO_NOT_COMPILE xine_artsplugin"
 ])
diff -urN kdemultimedia-3.1.orig/xine_artsplugin/xinePlayObject.mcopclass kdemultimedia-3.1/xine_artsplugin/xinePlayObject.mcopclass
--- kdemultimedia-3.1.orig/xine_artsplugin/xinePlayObject.mcopclass	Sun Oct 27 00:20:56 2002
+++ kdemultimedia-3.1/xine_artsplugin/xinePlayObject.mcopclass	Tue Jan 14 10:03:11 2003
@@ -1,7 +1,7 @@
 Interface=xinePlayObject,Arts::PlayObject,Arts::VideoPlayObject,Arts::SynthModule,Arts::Object
 Author=Ewald Snel <ewald@rambo.its.tudelft.nl>
-Extension=vob,mpg,mpeg,m1v,m2v,m1s,m2s,m2p,avi,asf,asx,wmv,qt,mov,moov
-MimeType=video/x-mpg,video/x-dat,video/x-mpeg,video/mpeg,video/x-msvideo,video/x-ms-asf,video/x-ms-wmv,video/quicktime,application/vnd.ms-asf
+Extension=vob,mpg,mpeg,m1v,m2v,m1s,m2s,m2p,avi,asf,asx,wmv,qt,mov,moov,rv,ra,ram,rm,smi
+MimeType=video/x-mpg,video/x-dat,video/x-mpeg,video/mpeg,video/x-msvideo,video/x-ms-asf,video/x-ms-wmv,video/quicktime,application/vnd.ms-asf,application/vnd.rn-realmedia,video/vnd.rn-realvideo,audio/vnd.rn-realaudio,audio/x-pn-realaudio
 Language=C++
 Library=libarts_xine.la
 Preference=4
diff -urN kdemultimedia-3.1.orig/xine_artsplugin/xinePlayObject_impl.cpp kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.cpp
--- kdemultimedia-3.1.orig/xine_artsplugin/xinePlayObject_impl.cpp	Fri Nov 22 20:42:23 2002
+++ kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.cpp	Tue Jan 14 10:03:11 2003
@@ -1,6 +1,6 @@
 /*
    This file is part of KDE/aRts (Noatun) - xine integration
-   Copyright (C) 2002 Ewald Snel <ewald@rambo.its.tudelft.nl>
+   Copyright (C) 2002-2003 Ewald Snel <ewald@rambo.its.tudelft.nl>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -15,62 +15,172 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <inttypes.h>
-#include <limits.h>
+#include <strings.h>
 #include <math.h>
 #include <audiosubsys.h>
 #include <convert.h>
 #include <debug.h>
+
 #include "xinePlayObject_impl.h"
 
-#define VPO_PLAY		1000
-#define VPO_QUIT		1001
-#define VPO_STOP		1002
+#define TIMEOUT		15	// 15 seconds
 
 using namespace Arts;
 
 
+// Global xine pointer
+static xine_t		*xine_shared	 = NULL;
+static pthread_mutex_t	 xine_mutex	 = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t	 xine_cond	 = PTHREAD_COND_INITIALIZER;
+static int		 xine_count	 = 0;
+static bool		 xine_force_xshm = false;
+
+static void xine_init_routine()
+{
+    const char *default_driver;
+    char cfg_filename[272];
+
+    xine_shared = (xine_t *)xine_new();
+
+    snprintf( cfg_filename, 272, "%s/.xine/config", getenv( "HOME" ) );
+
+    xine_config_load( xine_shared, (const char *)cfg_filename );
+
+    // Get default video output driver
+    default_driver = xine_config_register_string (xine_shared, "video.driver",
+						  "auto", "video driver to use",
+						  NULL, 10, NULL, NULL);
+
+    xine_force_xshm = (default_driver && !strcasecmp( default_driver, "XShm" ));
+
+    xine_init( xine_shared );
+}
+
+static void *xine_timeout_routine( void * )
+{
+    pthread_mutex_lock( &xine_mutex );
+
+    while (xine_shared != 0)
+    {
+	if (xine_count == 0)
+	{
+	    struct timespec ts;
+	    struct timeval tv;
+
+	    gettimeofday( &tv, 0 );
+
+	    ts.tv_sec	= tv.tv_sec;
+	    ts.tv_nsec	= tv.tv_usec * 1000;
+	    ts.tv_sec  += TIMEOUT;
+
+	    if (pthread_cond_timedwait( &xine_cond, &xine_mutex, &ts ) != 0 && xine_count == 0)
+	    {
+		xine_exit( xine_shared );
+		xine_shared = NULL;
+		break;
+	    }
+	}
+	else
+	{
+	    pthread_cond_wait( &xine_cond, &xine_mutex );
+	}
+    }
+    pthread_mutex_unlock( &xine_mutex );
+
+    return NULL;
+}
+
+static xine_t *xine_shared_init()
+{
+    pthread_mutex_lock( &xine_mutex );
+
+    ++xine_count;
+
+    if (xine_shared == 0)
+    {
+	pthread_t thread;
+
+	xine_init_routine();
+
+	if (pthread_create( &thread, NULL, xine_timeout_routine, NULL ) == 0)
+	{
+	    pthread_detach( thread );
+	}
+    }
+    else
+    {
+	pthread_cond_signal( &xine_cond );
+    }
+    pthread_mutex_unlock( &xine_mutex );
+
+    return xine_shared;
+}
+
+static void xine_shared_exit( xine_t * )
+{
+    pthread_mutex_lock( &xine_mutex );
+
+    if (--xine_count == 0)
+    {
+	pthread_cond_signal( &xine_cond );
+    }
+    pthread_mutex_unlock( &xine_mutex );
+}
+
 int ao_fifo_arts_delay()
 {
     return (int)(1000 * Arts::AudioSubSystem::the()->outputDelay());
 }
 
 xinePlayObject_impl::xinePlayObject_impl()
+    : mrl( "" ), xine( 0 ), stream( 0 ), queue( 0 ), ao_port( 0 ), vo_port( 0 )
 {
     XInitThreads();
 
-    if (!(video.display = XOpenDisplay( NULL )))
+    if (!(display = XOpenDisplay( NULL )))
     {
 	arts_fatal( "could not open X11 display" );
     }
 
-    XFlush( video.display );
+    XFlush( display );
 
     // Create a special window for uninterrupted X11 communication
-    video.xcom_window = XCreateSimpleWindow( video.display,
-					     DefaultRootWindow( video.display ),
-					     0, 0, 1, 1, 0, 0, 0 );
+    xcom_window = XCreateSimpleWindow( display, DefaultRootWindow( display ),
+				       0, 0, 1, 1, 0, 0, 0 );
 
-    XSelectInput( video.display, video.xcom_window, ExposureMask );
+    XSelectInput( display, xcom_window, ExposureMask );
 
-    pthread_cond_init( &cond, 0 );
     pthread_mutex_init( &mutex, 0 );
 
-    flpos		  = 0.0;
-    config		  = 0;
-    xine		  = 0;
-    ao_driver		  = 0;
-    vo_driver		  = 0;
+    // Initialize X11 properties
+    xcom_atom		   = XInternAtom( display, "VPO_INTERNAL_EVENT", False );
+    xcom_resize		   = XInternAtom( display, "VPO_RESIZE_NOTIFY", False );
+    screen		   = DefaultScreen( display );
+    shm_completion	   = (XShmQueryExtension( display ) == True)
+			     ? XShmGetEventBase( display ) + ShmCompletion : -1;
+#if 0
+    display_ratio	   = (double)(DisplayWidth( display, screen ) *
+				      DisplayHeightMM( display, screen ))
+				   / (DisplayWidthMM( display, screen ) *
+				      DisplayHeight( display, screen ));
+#endif
+    display_ratio	   = 1.0;
+
+    // Initialize xine visual structure
+    visual.display	   = display;
+    visual.screen	   = screen;
+    visual.d		   = xcom_window;
+    visual.dest_size_cb	   = &dest_size_cb;
+    visual.frame_output_cb = &frame_output_cb;
+    visual.user_data	   = this;
 
     // Initialize audio and video details
     Arts::SoundServerV2 server = Arts::Reference( "global:Arts_SoundServerV2" );
-    audio.sample_rate	  = 0;
-    audio.num_channels	  = 0;
-    audio.bits_per_sample = 0;
-
-    video.xcom_atom	  = XInternAtom( video.display, "VPO_INTERNAL_EVENT", False );
-    video.xcom_resize	  = XInternAtom( video.display, "VPO_RESIZE_NOTIFY", False );
-    video.window	  = video.xcom_window;
+    audio.sample_rate	   = 0;
+    audio.num_channels	   = 0;
+    audio.bits_per_sample  = 0;
+
+    flpos		   = 0.0;
 
     if (pthread_create( &thread, 0, pthread_start_routine, this ))
     {
@@ -80,28 +190,139 @@
 
 xinePlayObject_impl::~xinePlayObject_impl()
 {
+    XEvent event;
+
     halt();
 
-    // Send stop event to thread
-    sendEvent( video.xcom_window, VPO_QUIT );
+    // Send stop event to thread (X11 client message)
+    memset( &event, 0, sizeof(event) );
+
+    event.type			= ClientMessage;
+    event.xclient.window	= xcom_window;
+    event.xclient.message_type	= xcom_atom;
+    event.xclient.format	= 32;
+
+    XSendEvent( display, xcom_window, True, 0, &event );
 
+    XFlush( display );
+
+    // Wait for the thread to die
     pthread_join( thread, 0 );
-    pthread_cond_destroy( &cond );
+
+    // Destroy stream, xine and related resources
+    if (stream != 0)
+    {
+	halt();
+
+	xine_event_dispose_queue( queue );
+	xine_dispose( stream );
+	xine_close_audio_driver( xine, ao_port );
+	xine_close_video_driver( xine, vo_port );
+    }
+    if (xine != 0)
+    {
+	xine_shared_exit( xine );
+    }
+
     pthread_mutex_destroy( &mutex );
 
-    XSync( video.display, False );
-    XDestroyWindow( video.display, video.xcom_window );
-    XCloseDisplay( video.display );
+    XSync( display, False );
+    XDestroyWindow( display, xcom_window );
+    XCloseDisplay( display );
 }
 
-bool xinePlayObject_impl::loadMedia( const string &filename )
+bool xinePlayObject_impl::loadMedia( const string &url )
 {
-    halt();
+    bool result = false;
+
+    pthread_mutex_lock( &mutex );
+
+    mrl = "";
+
+    if (stream == 0)
+    {
+	if (xine == 0)
+	{
+	    xine = xine_shared_init();
+	}
+
+	ao_port = init_audio_out_plugin( xine, &audio, &ao_driver );
+
+	if (xine_force_xshm)
+	{
+	    vo_port = xine_open_video_driver( xine, "XShm",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (vo_port == 0)
+	{
+	    vo_port = xine_open_video_driver( xine, "Xv",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (vo_port == 0)
+	{
+	    vo_port = xine_open_video_driver( xine, "XShm",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (vo_port == 0)
+	{
+	    vo_port = xine_open_video_driver( xine, "OpenGL",
+					      XINE_VISUAL_TYPE_X11,
+					      (void *)&visual );
+	}
+	if (ao_port != 0 && vo_port != 0)
+	{
+	    stream = xine_stream_new( xine, ao_port, vo_port );
+
+	    if (stream != 0)
+	    {
+		xine_set_param( stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL, 0 );
+		xine_set_param( stream, XINE_PARAM_SPU_CHANNEL, -1 );
+
+		queue = xine_event_new_queue( stream );
+		xine_event_create_listener_thread( queue, xine_handle_event, this );
+	    }
+	}
+	if (stream == 0)
+	{
+	    if (ao_port != 0)
+	    {
+		xine_close_audio_driver( xine, ao_port );
+		ao_port = 0;
+	    }
+	    if (vo_port != 0)
+	    {
+		xine_close_video_driver( xine, vo_port );
+		vo_port = 0;
+	    }
+	}
+    }
+
+    if (stream != 0)
+    {
+	if (xine_get_status( stream ) == XINE_STATUS_PLAY)
+	{
+	    ao_fifo_clear( ao_driver, 2 );
+
+	    xine_stop( stream );
+
+	    clearWindow();
+	}
+	if ((result = xine_open( stream, url.c_str() )))
+	{
+	    mrl = url;
+	    resizeNotify();
+	}
 
-    // TODO: Should we protect this with a mutex?
-    mrl = filename;
+	stream_length = 0;
+	stream_position = 0;
+    }
 
-    return true; //running;
+    pthread_mutex_unlock( &mutex );
+
+    return result;
 }
 
 string xinePlayObject_impl::description()
@@ -112,12 +333,29 @@
 poTime xinePlayObject_impl::currentTime()
 {
     poTime time;
+    int pos_time;
 
     pthread_mutex_lock( &mutex );
 
-    time.seconds = (xine == 0) ? 0 : (long)xine_get_current_time( xine );
-    time.ms = 0;
+    if (stream != 0 && mrl != "")
+    {
+	if (xine_get_pos_length( stream, 0, &pos_time, 0 ))
+	{
+	    stream_position = pos_time;
+	}
+	else
+	{
+	    pos_time = stream_position;
+	}
 
+	time.seconds = pos_time / 1000;
+	time.ms = pos_time % 1000;
+    }
+    else
+    {
+	time.seconds = 0;
+	time.ms = 0;
+    }
     pthread_mutex_unlock( &mutex );
 
     return time;
@@ -126,25 +364,50 @@
 poTime xinePlayObject_impl::overallTime()
 {
     poTime time;
+    int length_time;
 
     pthread_mutex_lock( &mutex );
 
-    time.seconds = (xine == 0) ? 0 : (long)xine_get_stream_length( xine );
-    time.ms = 0;
+    if (stream != 0 && mrl != "")
+    {
+	if (xine_get_pos_length( stream, 0, 0, &length_time ))
+	{
+	    stream_length = length_time;
+	}
+	else
+	{
+	    length_time = stream_length;
+	}
 
-    pthread_mutex_unlock( &mutex );
+	if (length_time <= 0)
+	{
+	    length_time = 1;
+	}
 
-    if (!time.seconds && !time.ms)
+	time.seconds = length_time / 1000;
+	time.ms = length_time % 1000;
+    }
+    else
     {
+	time.seconds = 0;
 	time.ms = 1;
     }
+    pthread_mutex_unlock( &mutex );
 
     return time;
 }
 
 poCapabilities xinePlayObject_impl::capabilities()
 {
-    return static_cast<poCapabilities>( capPause | capSeek );
+    int n;
+
+    pthread_mutex_lock( &mutex );
+
+    n = (stream == 0) ? 0 : xine_get_stream_info( stream, XINE_STREAM_INFO_SEEKABLE );
+
+    pthread_mutex_unlock( &mutex );
+
+    return static_cast<poCapabilities>( capPause | ((n == 0) ? 0 : capSeek) );
 }
 
 string xinePlayObject_impl::mediaName()
@@ -158,9 +421,9 @@
 
     pthread_mutex_lock( &mutex );
 
-    if ((xine == 0) || xine_get_status( xine ) != XINE_PLAY)
+    if (stream == 0 || xine_get_status( stream ) != XINE_STATUS_PLAY)
 	state = posIdle;
-    else if (xine_get_speed( xine ) == SPEED_PAUSE)
+    else if (xine_get_param( stream, XINE_PARAM_SPEED ) == XINE_SPEED_PAUSE)
 	state = posPaused;
     else
 	state = posPlaying;
@@ -176,9 +439,10 @@
 
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && xine_get_status( xine ) == XINE_PLAY)
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	pixmap = (long)vo_fifo_snapshot( &video, xine );
+	// FIXME: snapshot...
+	pixmap = (long)-1;
     }
     pthread_mutex_unlock( &mutex );
 
@@ -191,60 +455,53 @@
 
     if (window == -1)
     {
-	window = video.xcom_window;
+	window = xcom_window;
     }
 
-    if ((Window)window != video.window)
+    if ((Window)window != visual.d)
     {
-	XLockDisplay( video.display );
+	XLockDisplay( display );
 
 	// Change window and set event mask of new window
-	video.window = window;
+	visual.d = window;
 
-	XSelectInput( video.display, window, ExposureMask );
+	XSelectInput( display, window, ExposureMask );
 
-	if (vo_driver)
+	if (stream != 0)
 	{
-	    vo_fifo_resize_notify( &video );
-	    vo_driver->gui_data_exchange( vo_driver,
-					  GUI_DATA_EX_DRAWABLE_CHANGED,
-					  (void *)video.window );
+	    resizeNotify();
+	    xine_gui_send_vo_data( stream,
+				   XINE_GUI_SEND_DRAWABLE_CHANGED,
+				   (void *)window );
 	}
 
-	XUnlockDisplay( video.display );
+	XUnlockDisplay( display );
     }
     pthread_mutex_unlock( &mutex );
 }
 
 long xinePlayObject_impl::x11WindowId()
 {
-    return (video.window == video.xcom_window) ? (long)-1 : video.window;
+    return (visual.d == xcom_window) ? (long)-1 : visual.d;
 }
 
 void xinePlayObject_impl::play()
 {
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && xine_get_status( xine ) == XINE_PLAY)
+    if (stream != 0)
     {
-	if (xine_get_speed( xine ) == SPEED_PAUSE)
+	if (xine_get_status( stream ) == XINE_STATUS_PLAY)
 	{
-	    xine_set_speed( xine, SPEED_NORMAL );
+	    if (xine_get_param( stream, XINE_PARAM_SPEED ) == XINE_SPEED_PAUSE)
+	    {
+	        xine_set_param( stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL );
+	    }
 	}
-    }
-    else
-    {
-	// Wait for the xine object to be destroyed
-	while (xine != 0)
+	else if (mrl != "")
 	{
-	    pthread_cond_wait( &cond, &mutex );
+	    xine_play( stream, 0, 0 );
 	}
-
-	// Send play event
-	sendEvent( video.xcom_window, VPO_PLAY );
-
-	// Wait for the xine object to start (or fail)
-	pthread_cond_wait( &cond, &mutex );
     }
     pthread_mutex_unlock( &mutex );
 }
@@ -253,19 +510,16 @@
 {
     pthread_mutex_lock( &mutex );
 
-    if (xine != 0)
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	if (xine_get_status( xine ) == XINE_PLAY)
-	{
-	    ao_fifo_wait_close( ao_driver );
+	ao_fifo_clear( ao_driver, 2 );
 
-	    xine_stop( xine );
-	}
+	xine_stop( stream );
 
-	sendEvent( video.xcom_window, VPO_STOP );
+	clearWindow();
 
-	// Wait for the xine object to be destroyed
-	pthread_cond_wait( &cond, &mutex );
+	stream_length = 0;
+	stream_position = 0;
     }
     pthread_mutex_unlock( &mutex );
 }
@@ -274,18 +528,27 @@
 {
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && (xine_get_status( xine ) == XINE_PLAY))
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	int paused = (xine_get_speed( xine ) == SPEED_PAUSE);
+	int seek_position = (1000 * t.seconds) + t.ms;
+	int paused = (xine_get_param( stream, XINE_PARAM_SPEED ) == XINE_SPEED_PAUSE);
 
-	ao_fifo_flush( ao_driver, ULONG_MAX );
+	ao_fifo_clear( ao_driver, 1 );
 
-	xine_play( xine, (char *)mrl.c_str(), 0, t.seconds );
+	if (xine_play( stream, 0, seek_position ))
+	{
+	    if (seek_position >= 0 && seek_position <= stream_length)
+	    {
+		stream_position = seek_position;
+	    }
+	}
 
 	if (paused)
 	{
-	    xine_set_speed( xine, SPEED_PAUSE );
+	    xine_set_param( stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE );
 	}
+
+	ao_fifo_clear( ao_driver, 0 );
     }
     pthread_mutex_unlock( &mutex );
 }
@@ -294,11 +557,11 @@
 {
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && (xine_get_status( xine ) == XINE_PLAY))
+    if (stream != 0 && xine_get_status( stream ) == XINE_STATUS_PLAY)
     {
-	xine_set_speed( xine, SPEED_PAUSE );
+	ao_fifo_clear( ao_driver, 1 );
 
-	ao_fifo_flush( ao_driver, ULONG_MAX );
+	xine_set_param( stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE );
     }
     pthread_mutex_unlock( &mutex );
 }
@@ -311,21 +574,12 @@
 
     pthread_mutex_lock( &mutex );
 
-    if ((xine != 0) && (xine_get_status( xine ) == XINE_PLAY))
+    if (stream != 0)
     {
-	if (xine_get_speed( xine ) != SPEED_PAUSE)
-	{
-	    // Calculate resampling parameters
-	    speed = (double)audio.sample_rate / samplingRateFloat;
-	    xSamples = (unsigned int)((double)samples * speed + 8.0);
-
-	    received = ao_fifo_read( ao_driver, &buffer, xSamples );
-	}
-	else
-	{
-	    // Clear audio buffer
-	    ao_fifo_flush( ao_driver, ULONG_MAX );
-	}
+	// Calculate resampling parameters
+	speed = (double)audio.sample_rate / samplingRateFloat;
+	xSamples = (unsigned int)((double)samples * speed + 8.0);
+	received = ao_fifo_read( ao_driver, &buffer, xSamples );
     }
 
     pthread_mutex_unlock( &mutex );
@@ -350,166 +604,122 @@
     }
 }
 
-void xinePlayObject_impl::playEvent()
+void xinePlayObject_impl::xineEvent( const xine_event_t *event )
 {
-    pthread_mutex_lock( &mutex );
-
-    running   = false;
-    vo_driver = init_video_out_plugin( config, &video );
-
-    if (vo_driver)
+    if (event->type == XINE_EVENT_UI_PLAYBACK_FINISHED)
     {
-	ao_driver = init_audio_out_plugin( config, &audio );
-
-	xine = xine_init( vo_driver, ao_driver, config );
-
-	xine_register_event_listener( xine, xine_handle_event, this );
-	xine_select_audio_channel( xine, 0 );
-	xine_select_spu_channel( xine, -1 );
-
-	running = xine_play( xine, (char *)mrl.c_str(), 0, 0 );
+	fprintf (stderr, "PLAYBACK FINISHED!");
 
-	if (!running)
-	{
-	    sendEvent( video.xcom_window, VPO_STOP );
-	}
-    }
-    if (!vo_driver || running)
-    {
-	pthread_cond_broadcast( &cond );
+	clearWindow();
     }
-    pthread_mutex_unlock( &mutex );
 }
 
-void xinePlayObject_impl::stopEvent()
+void xinePlayObject_impl::clearWindow()
 {
-    pthread_mutex_lock( &mutex );
+    Window root;
+    unsigned int u, w, h;
+    int x, y, screen;
 
-    if (xine != 0)
-    {
-	ao_fifo_wait_close( ao_driver );
+    XLockDisplay( display );
 
-	xine_remove_event_listener( xine, xine_handle_event );
-	xine_exit( xine );
+    screen = DefaultScreen( display );
 
-	xine	    = 0;
-	ao_driver   = 0;
-	vo_driver   = 0;
-    }
-    pthread_cond_broadcast( &cond );
-    pthread_mutex_unlock( &mutex );
+    XGetGeometry( display, visual.d, &root, &x, &y, &w, &h, &u, &u );
 
-    clearWindow();
-}
+    XSetForeground( display, DefaultGC( display, screen ),
+		    BlackPixel( display, screen ) );
+    XFillRectangle( display, visual.d,
+		    DefaultGC( display, screen ), x, y, w, h );
 
-void xinePlayObject_impl::xineEvent( xine_event_t *event )
-{
-    if (event->type == XINE_EVENT_PLAYBACK_FINISHED)
-    {
-	sendEvent( video.xcom_window, VPO_STOP );
-    }
+    XUnlockDisplay( display );
 }
 
-void xinePlayObject_impl::sendEvent( long window, long message )
+void xinePlayObject_impl::frameOutput( int *x, int *y, int *width, int *height, double *ratio )
 {
-    XEvent event;
+    Window child, root;
+    unsigned int u;
+    int n;
 
-    // Send X11 client message
-    memset( &event, 0, sizeof(event) );
+    XLockDisplay( display );
 
-    event.type			= ClientMessage;
-    event.xclient.window	= window;
-    event.xclient.message_type	= video.xcom_atom;
-    event.xclient.format	= 32;
-    event.xclient.data.l[0]	= message;
+    XGetGeometry( display, visual.d, &root, &n, &n,
+		  (unsigned int *)width, (unsigned int *)height, &u, &u );
 
-    XSendEvent( video.display, window, True, 0, &event );
+    if (x != 0 && y != 0)
+    {
+	XTranslateCoordinates( display, visual.d, root, 0, 0, x, y, &child );
+    }
 
-    XFlush( video.display );
+    *ratio = display_ratio;
+
+    XUnlockDisplay( display );
 }
 
-void xinePlayObject_impl::clearWindow()
+void xinePlayObject_impl::resizeNotify()
 {
-    Window root;
-    unsigned int u, w, h;
-    int x, y, screen;
+    XEvent event;
+    int width, height, ratio;
 
-    XLockDisplay( video.display );
+    width  = xine_get_stream_info( stream, XINE_STREAM_INFO_VIDEO_WIDTH );
+    height = xine_get_stream_info( stream, XINE_STREAM_INFO_VIDEO_HEIGHT );
+    ratio  = xine_get_stream_info( stream, XINE_STREAM_INFO_VIDEO_RATIO );
+
+    // Adjust video size to aspect ratio
+    if (ratio >= 1000 && ratio <= 100000)
+    {
+	if ((ratio * height) >= (10000 * width))
+	    width  = (1 + ((ratio * height) / 5000)) / 2;
+	else
+	    height = (1 + ((20000 * width) / ratio)) / 2;
+    }
 
-    screen = DefaultScreen( video.display );
+    // Resize notify signal for front-ends
+    memset( &event, 0, sizeof(event) );
 
-    XGetGeometry( video.display, video.window, &root, &x, &y, &w, &h, &u, &u );
+    event.type                  = ClientMessage;
+    event.xclient.window        = visual.d;
+    event.xclient.message_type  = xcom_resize;
+    event.xclient.format        = 32;
+    event.xclient.data.l[0]     = width;
+    event.xclient.data.l[1]     = height;
 
-    XSetForeground( video.display, DefaultGC( video.display, screen ),
-		    BlackPixel( video.display, screen ) );
-    XFillRectangle( video.display, video.window,
-		    DefaultGC( video.display, screen ), x, y, w, h );
+    XSendEvent( display, visual.d, True, 0, &event );
 
-    XUnlockDisplay( video.display );
+    XFlush( display );
 }
 
 void xinePlayObject_impl::eventLoop()
 {
     XEvent event;
-    string config_file = string( getenv( "HOME" )).append( "/.xine/config" );
-
-    config = xine_config_file_init( (char *)config_file.c_str() );
-
-    // Disable OSD
-    config->register_bool( config, (char *)"misc.osd_display", 0,
-			   (char *)"disabled for KDE", 0, 0, 0 );
-    config->update_num( config, (char *)"misc.osd_display", 0 );
 
-    // Disable xine logo
-    config->register_string( config, (char *)"misc.logo_mrl", (char *)"",
-			     (char *)"disabled for KDE", 0, 0, 0 );
-    config->update_string( config, (char *)"misc.logo_mrl", (char *)"" );
-
-    while (config)
+    do
     {
-	XNextEvent( video.display, &event );
+	XNextEvent( display, &event );
 
 	if (event.type == Expose && event.xexpose.count == 0 &&
-	    event.xexpose.window == video.window)
+	    event.xexpose.window == visual.d)
 	{
-	    if (vo_driver)
+	    if (stream != 0)
 	    {
-		vo_driver->gui_data_exchange( vo_driver,
-					      GUI_DATA_EX_EXPOSE_EVENT,
-					      &event );
+		xine_gui_send_vo_data( stream,
+				       XINE_GUI_SEND_EXPOSE_EVENT,
+				       &event );
 	    }
 	    else
 	    {
 		clearWindow();
 	    }
 	}
-	else if (event.type == video.shm_completion && vo_driver)
+	else if (event.type == shm_completion && stream != 0)
 	{
-	    vo_driver->gui_data_exchange( vo_driver,
-					  GUI_DATA_EX_COMPLETION_EVENT,
-					  &event );
-	}
-
-	if (event.type == ClientMessage &&
-	    event.xclient.message_type == video.xcom_atom &&
-	    event.xclient.window == video.xcom_window)
-	{
-	    switch (event.xclient.data.l[0])
-	    {
-	    case VPO_QUIT:
-		// Destroy xine config object (signal quit)
-		config->dispose( config );
-		config = 0;
-		break;
-	    case VPO_PLAY:
-		playEvent();
-		break;
-	    case VPO_STOP:
-		stopEvent();
-		break;
-	    }
+	    xine_gui_send_vo_data( stream,
+				   XINE_GUI_SEND_COMPLETION_EVENT,
+				   &event );
 	}
     }
+    while (event.type != ClientMessage ||
+	   event.xclient.message_type != xcom_atom ||
+	   event.xclient.window != xcom_window);
 }
 
 REGISTER_IMPLEMENTATION(xinePlayObject_impl);
diff -urN kdemultimedia-3.1.orig/xine_artsplugin/xinePlayObject_impl.h kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.h
--- kdemultimedia-3.1.orig/xine_artsplugin/xinePlayObject_impl.h	Sun Sep 15 23:14:53 2002
+++ kdemultimedia-3.1/xine_artsplugin/xinePlayObject_impl.h	Tue Jan 14 10:03:11 2003
@@ -1,6 +1,6 @@
 /*
    This file is part of KDE/aRts (Noatun) - xine integration
-   Copyright (C) 2002 Ewald Snel <ewald@rambo.its.tudelft.nl>
+   Copyright (C) 2002-2003 Ewald Snel <ewald@rambo.its.tudelft.nl>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -16,10 +16,10 @@
 #include <stdsynthmodule.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
+#include <X11/extensions/XShm.h>
 #include <xine.h>
-#include <xine/video_out_x11.h>
+
 #include "audio_fifo_out.h"
-#include "video_fifo_out.h"
 #include "xinePlayObject.h"
 
 
@@ -34,14 +34,13 @@
     xinePlayObject_impl();
     virtual ~xinePlayObject_impl();
 
-    bool loadMedia( const string &filename );
+    bool loadMedia( const string &url );
     string description();
     poTime currentTime();
     poTime overallTime();
     poCapabilities capabilities();
     string mediaName();
     poState state();
-    bool snapshot( long pixmap );
     long x11Snapshot();
     long x11WindowId();
     void x11WindowId( long window );
@@ -52,11 +51,10 @@
     void calculateBlock( unsigned long samples );
 
 protected:
-    void playEvent();
-    void stopEvent();
-    void xineEvent( xine_event_t *event );
-    void sendEvent( long window, long message );
+    void xineEvent( const xine_event_t *event );
     void clearWindow();
+    void frameOutput( int *x, int *y, int *width, int *height, double *ratio );
+    void resizeNotify();
     void eventLoop();
 
     // C -> C++ wrapper for pthread API
@@ -67,26 +65,63 @@
     }
 
     // C -> C++ wrapper for xine API
-    static inline void xine_handle_event( void *user_data, xine_event_t *event )
+    static inline void xine_handle_event( void *arg, const xine_event_t *event )
+    {
+	((xinePlayObject_impl *)arg)->xineEvent( event );
+    }
+
+    // C -> C++ wrapper for xine API
+    static inline void frame_output_cb( void *arg, int, int, double,
+					int *dest_x, int *dest_y,
+					int *dest_width, int *dest_height,
+					double *dest_pixel_aspect,
+					int *win_x, int *win_y )
     {
-	((xinePlayObject_impl *)user_data)->xineEvent( event );
+	((xinePlayObject_impl *)arg)->frameOutput( win_x, win_y,
+						   dest_width, dest_height,
+						   dest_pixel_aspect );
+
+	*dest_x = 0;
+	*dest_y = 0;
+    }
+
+    // C -> C++ wrapper for xine API
+    static inline void dest_size_cb( void *arg, int, int, double,
+				     int *dest_width, int *dest_height,
+				     double *dest_pixel_aspect )
+    {
+	((xinePlayObject_impl *)arg)->frameOutput( NULL, NULL,
+						   dest_width, dest_height,
+						   dest_pixel_aspect );
     }
 
 private:
-    double	     flpos;
-    string	     mrl;
-    bool	     running;
-
-    pthread_mutex_t  mutex;
-    pthread_cond_t   cond;
-    pthread_t	     thread;
-
-    config_values_t *config;
-    xine_t	    *xine;
-    ao_driver_t	    *ao_driver;
-    vo_driver_t	    *vo_driver;
-    xine_arts_audio  audio;
-    xine_arts_video  video;
+    double		 flpos;
+    string		 mrl;
+    string		 vo_driver_id;
+
+    pthread_mutex_t	 mutex;
+    pthread_t		 thread;
+
+    xine_t		*xine;
+    xine_stream_t	*stream;
+    xine_event_queue_t	*queue;
+    xine_audio_port_t	*ao_port;
+    void		*ao_driver;
+    xine_video_port_t	*vo_port;
+    x11_visual_t	 visual;
+    xine_arts_audio	 audio;
+
+    Display		*display;
+    Window		 xcom_window;
+    Atom		 xcom_atom;
+    Atom		 xcom_resize;
+    int			 screen;
+    int			 shm_completion;
+    double		 display_ratio;
+
+    int			 stream_length;
+    int			 stream_position;
 };
 
 #endif
