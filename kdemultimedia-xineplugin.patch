diff -urN kdemultimedia-3.0.8/xine_artsplugin/Makefile.am kdemultimedia-cvs/xine_artsplugin/Makefile.am
--- kdemultimedia-3.0.8/xine_artsplugin/Makefile.am	Sun Sep 15 23:14:53 2002
+++ kdemultimedia-cvs/xine_artsplugin/Makefile.am	Sat Oct  5 20:55:16 2002
@@ -1,6 +1,6 @@
-INCLUDES= -I$(kde_includes)/arts $(all_includes) $(XINE_CFLAGS)
+INCLUDES= -I$(kde_includes)/arts $(all_includes) $(XINE_INCS)
 
-AM_CFLAGS = -U__STRICT_ANSI__
+AM_CFLAGS = -U__STRICT_ANSI__ $(XINE_CFLAGS)
 
 lib_LTLIBRARIES = libarts_xine.la
 
@@ -10,10 +10,11 @@
 			  video_fifo_out.c
 libarts_xine_la_LDFLAGS = $(all_libraries) -module -avoid-version -pthread
 libarts_xine_la_LIBADD = $(XINE_LIBS) $(LIB_X11) $(LIB_XEXT) \
-			 -lkmedia2_idl -lsoundserver_idl -lartsflow -lrt
+			 -lkmedia2_idl -lsoundserver_idl -lartsflow
 
 libarts_xine_la_METASOURCES = AUTO
 
+$(srcdir)/xinePlayObject_impl.cpp: xinePlayObject.h
 xinePlayObject.cc xinePlayObject.h: $(srcdir)/xinePlayObject.idl
 	$(MCOPIDL) $(INCLUDES) $(srcdir)/xinePlayObject.idl
 
diff -urN kdemultimedia-3.0.8/xine_artsplugin/audio_fifo_out.c kdemultimedia-cvs/xine_artsplugin/audio_fifo_out.c
--- kdemultimedia-3.0.8/xine_artsplugin/audio_fifo_out.c	Sat Jun 15 03:00:55 2002
+++ kdemultimedia-cvs/xine_artsplugin/audio_fifo_out.c	Sat Oct  5 20:55:16 2002
@@ -127,6 +127,7 @@
 	while ((ao->bytes_in_buffer + n) > ao->buffer_size)
 	{
 	    struct timespec ts;
+	    struct timeval tv;
 	    int delay;
 
 	    if (!ao->enabled)
@@ -136,13 +137,10 @@
 		return 0;
 	    }
 
-#		ifdef HAVE_CLOCK_GETTIME
-	    /* wait until the buffer is empty */
-	    clock_gettime( CLOCK_REALTIME, &ts );
-#		else
-		gettimeofday((struct timeval*)&ts, 0);
-		ts.tv_nsec *= 1000;
-#		endif
+	    gettimeofday( &tv, 0 );
+
+	    ts.tv_sec	= tv.tv_sec;
+	    ts.tv_nsec	= tv.tv_usec * 1000;
 
 	    delay	= ao_fifo_arts_delay();
 	    delay      += (1000 * num_frames) / ao->audio->sample_rate;
diff -urN kdemultimedia-3.0.8/xine_artsplugin/configure.in.in kdemultimedia-cvs/xine_artsplugin/configure.in.in
--- kdemultimedia-3.0.8/xine_artsplugin/configure.in.in	Sat Jun 15 03:00:55 2002
+++ kdemultimedia-cvs/xine_artsplugin/configure.in.in	Sat Oct  5 20:55:16 2002
@@ -24,7 +24,7 @@
 dnl  
 
 dnl AC_PATH_XINE([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
-dnl Test for XINE, and define XINE_CFLAGS and XINE_LIBS
+dnl Test for XINE, and define XINE_CFLAGS, XINE_INCS, and XINE_LIBS
 dnl
 
 AC_DEFUN([AC_PATH_XINE],
@@ -63,7 +63,9 @@
     if test "$XINE_CONFIG" = "no" ; then
       no_xine=yes
     else
-      XINE_CFLAGS=`$XINE_CONFIG $xine_config_args --cflags`
+      _XINE_CFLAGS=`$XINE_CONFIG $xine_config_args --cflags`
+      XINE_CFLAGS=`echo ${_XINE_CFLAGS} | tr ' ' '\n' | grep -v -- ^-I`
+      XINE_INCS=`echo ${_XINE_CFLAGS} | tr ' ' '\n' | grep -- ^-I`
       XINE_LIBS=`$XINE_CONFIG $xine_config_args --libs`
       xine_config_major_version=`$XINE_CONFIG $xine_config_args --version | \
              sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
@@ -79,7 +81,7 @@
       dnl    if test "x$enable_xinetest" = "xyes" ; then
       ac_save_CFLAGS="$CFLAGS"
       ac_save_LIBS="$LIBS"
-      CFLAGS="$CFLAGS $XINE_CFLAGS"
+      CFLAGS="$CFLAGS $XINE_CFLAGS $XINE_INCS"
       LIBS="$XINE_LIBS $LIBS"
 dnl
 dnl Now check if the installed XINE is sufficiently new. (Also sanity
@@ -198,10 +200,12 @@
         fi
       fi
     XINE_CFLAGS=""
+    XINE_INCS=""
     XINE_LIBS=""
     ifelse([$3], , :, [$3])
   fi
   AC_SUBST(XINE_CFLAGS)
+  AC_SUBST(XINE_INCS)
   AC_SUBST(XINE_LIBS)
   AC_LANG_RESTORE()
   rm -f conf.xinetest
@@ -210,9 +214,3 @@
 [
   DO_NOT_COMPILE="$DO_NOT_COMPILE xine_artsplugin"
 ])
-
-
-
-AC_CHECK_FUNC(clock_gettime, [AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [Define if you don't want to be backwards compatible])])
-
-
diff -urN kdemultimedia-3.0.8/xine_artsplugin/video_fifo_out.c kdemultimedia-cvs/xine_artsplugin/video_fifo_out.c
--- kdemultimedia-3.0.8/xine_artsplugin/video_fifo_out.c	Sun Sep 15 23:14:53 2002
+++ kdemultimedia-cvs/xine_artsplugin/video_fifo_out.c	Sat Oct  5 20:55:16 2002
@@ -186,7 +186,7 @@
 {
     x11_visual_t vis;
     vo_driver_t *vo;
-    int screen, i;
+    int screen;
     char *video_driver_id;
 
     vo			  = 0;
diff -urN kdemultimedia-3.0.8/xine_artsplugin/xinePlayObject.cc kdemultimedia-cvs/xine_artsplugin/xinePlayObject.cc
--- kdemultimedia-3.0.8/xine_artsplugin/xinePlayObject.cc	Thu Jan  1 01:00:00 1970
+++ kdemultimedia-cvs/xine_artsplugin/xinePlayObject.cc	Wed Sep  4 21:08:55 2002
@@ -0,0 +1,143 @@
+/* this file was generated by the MCOP idl compiler - DO NOT EDIT */
+
+#include "xinePlayObject.h"
+
+// Implementation
+xinePlayObject_base *xinePlayObject_base::_create(const std::string& subClass)
+{
+	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
+	assert(skel);
+	xinePlayObject_base *castedObject = (xinePlayObject_base *)skel->_cast(xinePlayObject_base::_IID);
+	assert(castedObject);
+	return castedObject;
+}
+
+xinePlayObject_base *xinePlayObject_base::_fromString(const std::string& objectref)
+{
+	Arts::ObjectReference r;
+
+	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
+		return xinePlayObject_base::_fromReference(r,true);
+	return 0;
+}
+
+xinePlayObject_base *xinePlayObject_base::_fromDynamicCast(const Arts::Object& object)
+{
+	if(object.isNull()) return 0;
+
+	xinePlayObject_base *castedObject = (xinePlayObject_base *)object._base()->_cast(xinePlayObject_base::_IID);
+	if(castedObject) return castedObject->_copy();
+
+	return _fromString(object._toString());
+}
+
+xinePlayObject_base *xinePlayObject_base::_fromReference(Arts::ObjectReference r, bool needcopy)
+{
+	xinePlayObject_base *result;
+	result = (xinePlayObject_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"xinePlayObject");
+	if(result)
+	{
+		if(!needcopy)
+			result->_cancelCopyRemote();
+	}
+	else
+	{
+		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
+		if(conn)
+		{
+			result = new xinePlayObject_stub(conn,r.objectID);
+			if(needcopy) result->_copyRemote();
+			result->_useRemote();
+			if (!result->_isCompatibleWith("xinePlayObject")) {
+				result->_release();
+				return 0;
+			}
+		}
+	}
+	return result;
+}
+
+std::vector<std::string> xinePlayObject_base::_defaultPortsIn() const {
+	std::vector<std::string> ret;
+	return ret;
+}
+std::vector<std::string> xinePlayObject_base::_defaultPortsOut() const {
+	std::vector<std::string> ret;
+	return ret;
+}
+
+void *xinePlayObject_base::_cast(unsigned long iid)
+{
+	if(iid == xinePlayObject_base::_IID) return (xinePlayObject_base *)this;
+	if(iid == Arts::PlayObject_base::_IID) return (Arts::PlayObject_base *)this;
+	if(iid == Arts::PlayObject_private_base::_IID) return (Arts::PlayObject_private_base *)this;
+	if(iid == Arts::VideoPlayObject_base::_IID) return (Arts::VideoPlayObject_base *)this;
+	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
+	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
+	return 0;
+}
+
+xinePlayObject_stub::xinePlayObject_stub()
+{
+	// constructor for subclasses (don't use directly)
+}
+
+xinePlayObject_stub::xinePlayObject_stub(Arts::Connection *connection, long objectID)
+	: Arts::Object_stub(connection, objectID)
+{
+	// constructor to create a stub for an object
+}
+
+std::string xinePlayObject_skel::_interfaceName()
+{
+	return "xinePlayObject";
+}
+
+bool xinePlayObject_skel::_isCompatibleWith(const std::string& interfacename)
+{
+	if (interfacename == "xinePlayObject") return true;
+	if (interfacename == "Arts::PlayObject") return true;
+	if (interfacename == "Arts::PlayObject_private") return true;
+	if (interfacename == "Arts::VideoPlayObject") return true;
+	if (interfacename == "Arts::SynthModule") return true;
+	if (interfacename == "Arts::Object") return true;
+	return false;
+}
+
+std::string xinePlayObject_skel::_interfaceNameSkel()
+{
+	return "xinePlayObject";
+}
+
+void xinePlayObject_skel::_buildMethodTable()
+{
+	Arts::Buffer m;
+	m.fromString(
+        "MethodTable:",
+		"MethodTable"
+	);
+	Arts::PlayObject_skel::_buildMethodTable();
+	Arts::VideoPlayObject_skel::_buildMethodTable();
+	Arts::SynthModule_skel::_buildMethodTable();
+}
+
+xinePlayObject_skel::xinePlayObject_skel()
+{
+	_initStream("left",&left,10);
+	_initStream("right",&right,10);
+}
+
+Arts::Object_base* xinePlayObject::_Creator() {
+	return xinePlayObject_base::_create();
+}
+
+unsigned long xinePlayObject_base::_IID = Arts::MCOPUtils::makeIID("xinePlayObject");
+
+static Arts::IDLFileReg IDLFileReg_xinePlayObject("xinePlayObject",
+    "IDLFile:00000001000000000000000000000000010000000f78696e65506c61794f62"
+    "6a656374000000000300000011417274733a3a506c61794f626a656374000000001641"
+    "7274733a3a566964656f506c61794f626a6563740000000012417274733a3a53796e74"
+    "684d6f64756c65000000000000000002000000056c6566740000000006666c6f617400"
+    "0000000a000000000000000672696768740000000006666c6f6174000000000a000000"
+    "00000000000000000000000000"
+);
diff -urN kdemultimedia-3.0.8/xine_artsplugin/xinePlayObject.h kdemultimedia-cvs/xine_artsplugin/xinePlayObject.h
--- kdemultimedia-3.0.8/xine_artsplugin/xinePlayObject.h	Thu Jan  1 01:00:00 1970
+++ kdemultimedia-cvs/xine_artsplugin/xinePlayObject.h	Wed Sep  4 21:08:55 2002
@@ -0,0 +1,238 @@
+/* this file was generated by the MCOP idl compiler - DO NOT EDIT */
+
+#ifndef XINEPLAYOBJECT_H
+#define XINEPLAYOBJECT_H
+
+#include "common.h"
+
+// includes of other idl definitions
+#include "kmedia2.h"
+#include "artsflow.h"
+#include "soundserver.h"
+#include "core.h"
+
+class xinePlayObject;
+
+class xinePlayObject_base : virtual public Arts::PlayObject_base,
+	virtual public Arts::VideoPlayObject_base,
+	virtual public Arts::SynthModule_base {
+public:
+	static unsigned long _IID; // interface ID
+
+	static xinePlayObject_base *_create(const std::string& subClass = "xinePlayObject");
+	static xinePlayObject_base *_fromString(const std::string& objectref);
+	static xinePlayObject_base *_fromReference(Arts::ObjectReference ref, bool needcopy);
+
+	static xinePlayObject_base *_fromDynamicCast(const Arts::Object& object);
+	inline xinePlayObject_base *_copy() {
+		assert(_refCnt > 0);
+		_refCnt++;
+		return this;
+	}
+
+	virtual std::vector<std::string> _defaultPortsIn() const;
+	virtual std::vector<std::string> _defaultPortsOut() const;
+
+	void *_cast(unsigned long iid);
+
+};
+
+class xinePlayObject_stub : virtual public xinePlayObject_base, virtual public Arts::PlayObject_stub,
+	virtual public Arts::VideoPlayObject_stub,
+	virtual public Arts::SynthModule_stub {
+protected:
+	xinePlayObject_stub();
+
+public:
+	xinePlayObject_stub(Arts::Connection *connection, long objectID);
+
+};
+
+class xinePlayObject_skel : virtual public xinePlayObject_base, virtual public Arts::PlayObject_skel,
+	virtual public Arts::VideoPlayObject_skel,
+	virtual public Arts::SynthModule_skel {
+protected:
+	// variables for streams
+	float *left;                              // outgoing stream
+	float *right;                             // outgoing stream
+
+public:
+	xinePlayObject_skel();
+
+	static std::string _interfaceNameSkel();
+	std::string _interfaceName();
+	bool _isCompatibleWith(const std::string& interfacename);
+	void _buildMethodTable();
+	void dispatch(Arts::Buffer *request, Arts::Buffer *result,long methodID);
+};
+
+#include "reference.h"
+class xinePlayObject : public Arts::Object {
+private:
+	static Arts::Object_base* _Creator();
+	xinePlayObject_base *_cache;
+	inline xinePlayObject_base *_method_call() {
+		_pool->checkcreate();
+		if(_pool->base) {
+			_cache=(xinePlayObject_base *)_pool->base->_cast(xinePlayObject_base::_IID);
+			assert(_cache);
+		}
+		return _cache;
+	}
+
+protected:
+	inline xinePlayObject(xinePlayObject_base* b) : Arts::Object(b), _cache(0) {}
+
+
+public:
+	typedef xinePlayObject_base _base_class;
+
+	inline xinePlayObject() : Arts::Object(_Creator), _cache(0) {}
+	inline xinePlayObject(const Arts::SubClass& s) :
+		Arts::Object(xinePlayObject_base::_create(s.string())), _cache(0) {}
+	inline xinePlayObject(const Arts::Reference &r) :
+		Arts::Object(r.isString()?(xinePlayObject_base::_fromString(r.string())):(xinePlayObject_base::_fromReference(r.reference(),true))), _cache(0) {}
+	inline xinePlayObject(const Arts::DynamicCast& c) : Arts::Object(xinePlayObject_base::_fromDynamicCast(c.object())), _cache(0) {}
+	inline xinePlayObject(const xinePlayObject& target) : Arts::Object(target._pool), _cache(target._cache) {}
+	inline xinePlayObject(Arts::Object::Pool& p) : Arts::Object(p), _cache(0) {}
+	inline static xinePlayObject null() {return xinePlayObject((xinePlayObject_base*)0);}
+	inline static xinePlayObject _from_base(xinePlayObject_base* b) {return xinePlayObject(b);}
+	inline xinePlayObject& operator=(const xinePlayObject& target) {
+		if (_pool == target._pool) return *this;
+		_pool->Dec();
+		_pool = target._pool;
+		_cache = target._cache;
+		_pool->Inc();
+		return *this;
+	}
+	inline operator Arts::PlayObject() const { return Arts::PlayObject(*_pool); }
+	inline operator Arts::PlayObject_private() const { return Arts::PlayObject_private(*_pool); }
+	inline operator Arts::VideoPlayObject() const { return Arts::VideoPlayObject(*_pool); }
+	inline operator Arts::SynthModule() const { return Arts::SynthModule(*_pool); }
+	inline xinePlayObject_base* _base() {return _cache?_cache:_method_call();}
+
+	inline std::string description();
+	inline Arts::poTime currentTime();
+	inline Arts::poTime overallTime();
+	inline Arts::poCapabilities capabilities();
+	inline std::string mediaName();
+	inline Arts::poState state();
+	inline void play();
+	inline void seek(const Arts::poTime& newTime);
+	inline void pause();
+	inline void halt();
+	inline bool loadMedia(const std::string& filename);
+	inline long x11WindowId();
+	inline void x11WindowId(long _newValue);
+	inline long x11Snapshot();
+	inline Arts::AutoSuspendState autoSuspend();
+	inline void start();
+	inline void stop();
+	inline void streamInit();
+	inline void streamStart();
+	inline void streamEnd();
+};
+
+// Forward wrapper calls to _base classes:
+
+inline std::string xinePlayObject::description()
+{
+	return _cache?static_cast<Arts::PlayObject_base*>(_cache)->description():static_cast<Arts::PlayObject_base*>(_method_call())->description();
+}
+
+inline Arts::poTime xinePlayObject::currentTime()
+{
+	return _cache?static_cast<Arts::PlayObject_base*>(_cache)->currentTime():static_cast<Arts::PlayObject_base*>(_method_call())->currentTime();
+}
+
+inline Arts::poTime xinePlayObject::overallTime()
+{
+	return _cache?static_cast<Arts::PlayObject_base*>(_cache)->overallTime():static_cast<Arts::PlayObject_base*>(_method_call())->overallTime();
+}
+
+inline Arts::poCapabilities xinePlayObject::capabilities()
+{
+	return _cache?static_cast<Arts::PlayObject_base*>(_cache)->capabilities():static_cast<Arts::PlayObject_base*>(_method_call())->capabilities();
+}
+
+inline std::string xinePlayObject::mediaName()
+{
+	return _cache?static_cast<Arts::PlayObject_base*>(_cache)->mediaName():static_cast<Arts::PlayObject_base*>(_method_call())->mediaName();
+}
+
+inline Arts::poState xinePlayObject::state()
+{
+	return _cache?static_cast<Arts::PlayObject_base*>(_cache)->state():static_cast<Arts::PlayObject_base*>(_method_call())->state();
+}
+
+inline void xinePlayObject::play()
+{
+	 _cache?static_cast<Arts::PlayObject_base*>(_cache)->play():static_cast<Arts::PlayObject_base*>(_method_call())->play();
+}
+
+inline void xinePlayObject::seek(const Arts::poTime& newTime)
+{
+	 _cache?static_cast<Arts::PlayObject_base*>(_cache)->seek(newTime):static_cast<Arts::PlayObject_base*>(_method_call())->seek(newTime);
+}
+
+inline void xinePlayObject::pause()
+{
+	 _cache?static_cast<Arts::PlayObject_base*>(_cache)->pause():static_cast<Arts::PlayObject_base*>(_method_call())->pause();
+}
+
+inline void xinePlayObject::halt()
+{
+	 _cache?static_cast<Arts::PlayObject_base*>(_cache)->halt():static_cast<Arts::PlayObject_base*>(_method_call())->halt();
+}
+
+inline bool xinePlayObject::loadMedia(const std::string& filename)
+{
+	return _cache?static_cast<Arts::PlayObject_private_base*>(_cache)->loadMedia(filename):static_cast<Arts::PlayObject_private_base*>(_method_call())->loadMedia(filename);
+}
+
+inline long xinePlayObject::x11WindowId()
+{
+	return _cache?static_cast<Arts::VideoPlayObject_base*>(_cache)->x11WindowId():static_cast<Arts::VideoPlayObject_base*>(_method_call())->x11WindowId();
+}
+
+inline void xinePlayObject::x11WindowId(long _newValue)
+{
+	 _cache?static_cast<Arts::VideoPlayObject_base*>(_cache)->x11WindowId(_newValue):static_cast<Arts::VideoPlayObject_base*>(_method_call())->x11WindowId(_newValue);
+}
+
+inline long xinePlayObject::x11Snapshot()
+{
+	return _cache?static_cast<Arts::VideoPlayObject_base*>(_cache)->x11Snapshot():static_cast<Arts::VideoPlayObject_base*>(_method_call())->x11Snapshot();
+}
+
+inline Arts::AutoSuspendState xinePlayObject::autoSuspend()
+{
+	return _cache?static_cast<Arts::SynthModule_base*>(_cache)->autoSuspend():static_cast<Arts::SynthModule_base*>(_method_call())->autoSuspend();
+}
+
+inline void xinePlayObject::start()
+{
+	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->start():static_cast<Arts::SynthModule_base*>(_method_call())->start();
+}
+
+inline void xinePlayObject::stop()
+{
+	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->stop():static_cast<Arts::SynthModule_base*>(_method_call())->stop();
+}
+
+inline void xinePlayObject::streamInit()
+{
+	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamInit():static_cast<Arts::SynthModule_base*>(_method_call())->streamInit();
+}
+
+inline void xinePlayObject::streamStart()
+{
+	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamStart():static_cast<Arts::SynthModule_base*>(_method_call())->streamStart();
+}
+
+inline void xinePlayObject::streamEnd()
+{
+	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamEnd():static_cast<Arts::SynthModule_base*>(_method_call())->streamEnd();
+}
+
+#endif /* XINEPLAYOBJECT_H */
